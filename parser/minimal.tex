\secrel{Минимальный парсер}\label{miniparser}

Рассмотрим минимальный парсер, который может анализировать файлы текстовых
данных (например исходники программ), и вычленять из них последовательности
символов, которые можно отнести к \termdef{скалярам}: символ, строка и число.
\note{эти три типа можно назвать атомами computer science}

\lstx{Лексер \file{minimal.lpp}\
/\prog{flex}/}{parser/minimal.lpp}\label{minilexer}

\begin{description}
\item{(../bi/)\file{hpp.hpp}} содержит определения интерфейса лексера
\ref{lexinterface}, и ядра языка \bi\ \ref{bicore}\ для хранения результатов
разбора текстовых данных
\item{\var{noyywrap}} выключает использование функции \var{yywrap()}
\item{\var{yylineno}} включает отслеживание строки исходного файла, используется
при выводе сообщений об ошибках. В минимальном парсере не используется, но
требуется для сборки \bi-ядра.
\item{\verb|%%..%%|} набор правил группировки отдельных символов в
элементы данных\ --- \termdef{токены}{токен}, правила задаются с помощью \term{регулярных
выражений}
\item{\verb|TOC(Sym,SYM)|}\label{minisym} единственное правило, распознающее
любые группы сиволов как класс \class{bi::sym}: латинские буквы, цифры и символы
\_\ и .\ (точка)\note{точка добавлена, так часто используется в именах файлов}
\end{description}

\lstx{Парсер \file{minimal.ypp}\ /\prog{bison}/}{parser/minimal.ypp}

\begin{description}
\item{\file{hpp.hpp}} заголовок аналогичен лексеру \ref{minilexer}
\item{\verb|%defines %union|} указывает какие типы данных могут храниться в
узлах разобранного \termdef{синтаксического дерева}{синтаксическое дерево}.
Поскольку мы используем \bi-ядро, нам будет достаточно пользоваться
только классами языка \bi,
прежде всего универсальным символьным типом AST \ref{ast}\ и его прозводными
классами.
\item{\verb|%token|} описывает токены, которые может возвращать лексер
\ref{minlexer}, причем набор токенов должен быть согласованным между лексером и
парсером\note{определение токенов генерируется в файл \file{ypp.tab.hpp}}
\item{\verb|%type|} описывает типы синтаксических выражений, которые может
распознавать \termdef{грамматика}{грамматика} синтаксического анализатора, 
\item{\verb|REPL|} выражение, описывающее грамматику, аналогичную простейшему
варианту цикла REPL: Read Eval Print
Loop\note{чтение/вычисление/вывод/повторить}. В нашем случае часть вычисления
Eval не выполняется\note{разобранное выражение не вычисляется, хотя
используемое ядро \bi\ и поддерживает такой функционал}, а часть Print
выполняется через метод \verb|Sym.tagval()|, возвращающий котороткую строку
вида \verb|<класс:значение>|\ для найденного токена.
\item{\verb|ex|} (expression) универсальное символьное выражение языка \bi, в
нашем случае оно должно представлять только \verb|scalar|
\item{\verb|scalar|} выражение, представляющиее только распознаваемые скаляры:
\item{\verb|SYM|} символ, 
\item{\verb|STR|} строку \emph{или}
\item{\verb|NUM|} число\note{числа в грамматике языка \bi\ по типам не делятся,
токен соответствует как \class{int}, так и \class{num}}
\end{description}

В качестве тестового исходника возьмем \cpp\ код ядра языка \bi:
\file{../bi/cpp.cpp}:

\lstx{\file{minimal.src}: Тестовый исходник}{parser/minimal.src}

\lstx{\file{minimal.log}: Результат прогона}{parser/minimal.log}

Как видно по логу \file{minimal.log}, все группы сиволов, соответствующих
правилу лексера \verb|SYM|\ref{minisym}, распознались как объекты \bi, остальные
остались символами и попали в лог без изменений.
