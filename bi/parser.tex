\secrel{Синтаксический анализатор}\secdown

Синтаксис языка \bi\ был выбран алголо-подобным, более близким к современным
императивным языкам типа \cpp\ и \py. Использование типовых утилит-генераторов
позволяет легко описать синтаксис с инфиксными операторами и скобочной записью
для композитных типов\,\ref{bicompose}, и не заставлять пользователя
закапываться в клубок \lispовских скобок.

Инфиксный синтаксис \emph{для файлов конфигурации}\ удобен неподготовленным
пользователям, а возможность определения пользовательских функций и объектная
система, встроенная в ядро \bi, дает богатейшие возможности по настройке
и кастомизации программ.

Единственной проблемой с точки зрения синтаксиса для начинающего пользователя
\bi\ может оказаться отказ от скобок при вызове функций, применение оператора
явной аппликации \verb|@|, и функциональные наклонности самого \bi,
претендующего на звание универсального \emph{объектного мета-языка}\ и
\emph{языка шаблонов}.

\secrel{\file{lpp.lpp}: лексер /flex/}\label{bilexer}

\lstx{lpp.lpp}{../stoned/lpp.lpp}

\secrel{\file{ypp.ypp}: парсер /bison/}\label{biparser}

\lstx{ypp.ypp}{bi/ypp.ypp}

В качестве типа-хранилища для узлов синтаксического дерева идеально подходит
базовый символьный тип \bi\ \ref{ast}, причем его применение в этом качестве
рассматривалось как основное: гибкое представление произвольных типов данных.
Собственно его название намекает.

В качестве токенов-скаляров логично выбираются SYMвол, STRока и число
NUM\note{их можно вообще рассматривать как элементарные частицы Computer
Science, правда к ним еще придется добавить PTR: божественный указатель}. Надо
отметить, что в принципе можно было бы обойтись единственным SYM, но для
дополнительного контроля грамматики полезно выделить несколько токенов: это
позволит гарантировать что в определении класса \ref{biclass}\ вы сможете
использовать в качестве суперкласса и имен полей только символы. По крайне мере
до момента, когда в очередном форке \bi\ не появится возможность наследовать
любые объекты.

\secup
