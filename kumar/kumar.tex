\secrel{Программирование встраиваемых систем с использованием \gnut\
\cite{kumar}}\label{kumaru}\secdown \copyright\ Vijay Kumar B.\ 
\cp{http://bravegnu.org/gnu-eprog/}
перевод \cp{https://github.com/ponyatov/gnu-eprog/blob/ru/gnu-eprog.asciidoc}

\secrel{Введение}

Пакет компиляторов GNU toolchain широко используется при разработке программного
обеспечения для встраиваемых систем. Этот тип разработки ПО также называют
\termdef{низкоуровневым}{низкоуровневое программирование},
\termdef{standalone}{standalone}\ или \termdef{bare metal}{bare metal}\
программированием (на \ci\ и \cpp). Написание низкоуровневого кода на \ci\
добавляет программисту новых проблем, требующих глубокого понимания инструмента
разработчика\ --- \gnut. Руководства разработчика \gnut\ предоставляют отличную
информацию по инструментарию, но с точки зрения самого \gnut, чем с точки зрения
решаемой проблемы. Поэтому было написано это руководство, в котором будут
описаны типичные проблемы, с которыми сталкивается начинающий разработчик.

Этот учебник стремится занять свое место, объясняя использование \gnut\ с точки
зрения практического использования. Надеемся, что его будет достаточно для
разработчиков, собирающихся освоить и использовать \gnut\ в их embedded
проектах.

В иллюстративных целях была выбрана встроенная система на базе процессорного
ядра ARM, которая эмулируется в пакете \qemu. С таким подходом вы сможете
освоить \gnut\ с комфортом на вашем рабочем компьютере, без необходимости
вкладываться в ``физическое''\ железо, и бороться со сложностями с его запуском.
Учебник не стремиться обучить работе с архитектурой ARM, для этого вам нужно
будет воспользоваться дополнительными книгами или онлайн-учебниками типа:

\begin{itemize}[nosep]
  \item ARM Assembler\ \url{http://www.heyrick.co.uk/assembler/}
  \item ARM Assembly Language Programming\
  \url{http://www.arm.com/miscPDFs/9658.pdf}
\end{itemize}

Но для удобства читателя, некоторое множество часто используемых ARM-инструкций
описано в приложении \ref{kumarB}.

\secrel{Настройка тестового стенда}\secdown

В этом разделе описано, как настроить на вашей рабочей станции простую среду
разработки и тестирования ПО для платформы ARM, используя \qemu\ и \gnut.
\qemu\ это программный\note{для i386\ --- программно-аппаратный, использует
средства виртуализации хост-компьютера} эмулятор нескольких распространенных
аппаратных платформ. Вы можете написать программу на ассемблере и \cpp,
скомпилировать ее используя \gnut\ и отладить ее в эмуляторе \qemu.

\secrel{\qemu\ ARM}

Будем использовать \qemu\ для эмуляции отладочной платы \prog{Gumstix connex}\ на базе
процессора PXA255. Для работы с этим учебником у вас должен быть установлен
\qemu\ версии не ниже 0.9.1.

Процессор\note{Точнее SoC: система-на-кристалле}\ PXA255 имеет ядро ARM c
набором инструкций ARMv5TE. PXA255 также имеет в своем составе несколько блоков
периферии. Некоторая периферия будет описана в этом курсе далее.

\secrel{Инсталляция \qemu\ на \debian}

Этот учебник требует \qemu\ версии не ниже 0.9.1. Пакет \qemu\ доступный для
современных дистрибутивов \debian, вполне удовлетворяет этим условиям, и
собирать свежий \qemu\ из исходников совсем не требуется\note{хотя может быть и
очень хочется}. Установим пакет командой:

\begin{verbatim}
$ sudo apt install qemu
\end{verbatim}

\secrel{Установка кросс-компилятора \gnut\ для ARM}

Если вы предпочитаете простые пути, установите пакет кросс-компилятора командной

\begin{verbatim}
sudo apt install gcc-arm-none-eabi
\end{verbatim}

или

\begin{enumerate}
  \item Годные чуваки из CodeSourcery\note{подразделение Mentor
  Graphics}\ уже давно запилили несколько вариантов \gnut ов для разных ходовых
  архитектур. Скачайте готовую бинарную бесплатную lite-сборку
  \href{http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/}{\gnut-ARM}
  
\item Распакуйте tar-архив в каталог \dir{~/toolchains}:

\begin{verbatim}
$ mkdir ~/toolchains
$ cd ~/toolchains
$ tar -jxf ~/downloads/arm-2008q1-126-arm-none-eabi-i686-pc-linux-gnu.tar.bz2
\end{verbatim}

  \item Добавьте bin-каталог тулчейна в переменную среды \var{PATH}.

\begin{verbatim}
$ PATH=$HOME/toolchains/arm-2008q1/bin:$PATH 
\end{verbatim}

\item Чтобы каждый раз не выполнять предыдущую команду, вы можете прописать
ее в дот-файл \file{.bashrc}.

\end{enumerate}

Для совсем упертых подойдет рецепт сборки полного комплекта кросс-компилятора из
исходных тектов, описанный в \ref{cross}.

\secup
\secrel{Hello ARM}\secdown

В этом разделе вы научитесь пользоваться arm-ассемблером, и тестировать вашу
программу на голом железе\ --- эмуляторе платы \prog{connex}\ в \qemu.

Файл исходника ассемблерной программы состоит из последовательности инструкций,
по одной на каждую строку. Каждая инструкция имеет формат (каждый
компонент не обязателен):

\begin{verbatim}
<метка>:    <инструкция>         @ <комментарий>
\end{verbatim}

\begin{description}
\item[метка]\ --- типичный способ пометить адрес инструкции в памяти. Метка
может быть использована там, где требуется указать адрес, например как операнд
в команде перехода. Метка может состоять из латинских букв, цифр\note{не может
быть первым символом метки}, символов \verb|_|\ и \verb|$|.
\item[комментарий]\ начинается с символа \verb|@|\ --- все последующие символы
игнориуются до конца строки
\item[инструкция]\ может быть инструкцией процессора или директивой ассемблера,
начинающейся с точки ``.''
\end{description}

Вот пример простой ассемблерной программы \ref{kumarL1}\ для процессора ARM,
складывающей два числа:

\lstv{Сложение двух чисел}{kumar/add.s}\label{kumarL1}

\verb|.text|\ ассемблерная директива, указывающая что последующий код должен
быть \term{ассемблирован}\ в \termdef{секцию кода \var{.text}}, а не в секцию
\var{.data}. \term{Секции}\ будут подробно описаны далее.

\secrel{Сборка бинарника}

Сохраните программу в файл \file{add.s}\ \note{.s или .S стандарное расширение в
мире OpenSource, указывает что это файл с программной на ассемблере}.
Для ассемблирования файла вызовите ассемблер \prog{as}:

\begin{verbatim}
$ arm-none-eabi-as -o add.o add.s
\end{verbatim}

Опция \verb|-o|\ указывает выходной файл с \termdef{объектным кодом}{объектный
код}, имеющий стандартное расширение \verb|.o|\note{и внутренний формат ELF (как
завещал великий \linux)}.

\begin{framed}
\noindent Команды кросс-тулчейна всегда имеют префикс целевой архитектуры
(target triplet), для которой они были собраны, чтобы предотвратить
конфликт имен с хост-тулчейном для вашего рабочего компьютера. Далее утилиты
\gnut\ будут использоваться без префикса для лучшей читаемости. \emph{не
забывайте добавлять \prog{arm-none-eabi-}, иначе получите множество странных
ошибок типа ``unexpected command''}.
\end{framed}

\begin{verbatim}
$ (arm-none-eabi-)as -o add.o add.s
$ (arm-none-eabi-)objdump -x add.o
\end{verbatim}
\lstx{вывод команды \prog{arm-none-eabi-objdump\ -x}:  
ELF-заголовки в файле объектного кода}{kumar/add.objdump}

Секция \var{.text}\ имеет размер \verb|Size=0x0010|\ =16 байт, и содержит
\emph{машинный код}:

\lstx{машинный код из секции \var{.text}: \prog{objdump -d}}{kumar/add.disasm}

\bigskip
Для генерации \emph{исполняемого файла}\note{обычно тот же формат ELF.o,
слепленный из одного или нескольких объектных файлов, с некоторыми
модификациями см. опцию -T далее}\ вызовем \termdef{линкер}{линкер}\ \prog{ld}:

\begin{verbatim}
$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o
\end{verbatim}

Опять, опция \verb|-o|\ задает выходной файл. \verb|-Ttext=0x0|\ явно указывает
адрес, от которого будут отсчитываться все метки, т.е. секция инструкций
начинается с адреса \verb|0x0000|. Для просмотра адресов, назначенных меткам,
можно использовать команду \verb|(arm-none-eabi-)nm|\ \note{NaMes}:

\begin{verbatim}
ponyatov@bs:/tmp$ arm-none-eabi-nm add.elf
...
00000000 t start
0000000c t stop
\end{verbatim}
* если вы забудете опцию -T, вы получите этот вывод с адресами \verb|00008xxx|\
--- эти адреса были заданы при компиляции \gnut-ARM, и могут не совпадать
с необходимыми вам. Проверяйте ваши .elfы с помощью \prog{nm}\ или
\prog{objdump}, если программы не запускаются, или \qemu\ ругается на ошибки
(защиты) памяти.
\bigskip

Обратите внимание на \termdef{назначение адресов}{назначение адресов}\ для меток
\var{start}\ и \var{stop}: адреса начанаются с 0x0. Это адрес первой инструкции.
Метка \var{stop}\ находится после третьей инструкции. Каждая инструкция занимает
4 байта\note{в множестве команд ARM-32, если вы компилируете код для
микроконтроллера \cm x в режиме команд Thumb или Thumb2, команды 16-битные, т.е.
2 байта}, так что \var{stop}\ находится по адресу 0x$C_{hex}=12_{dec}$.
\termdef{Линковка}{линковка}\ с другим \termdef{базовым адресом}{базовый
адрес}\ \verb|-Ttext=nnnn|\ приведет к сдвигу адресов, назначенных меткам.

\begin{verbatim}
$ arm-none-eabi-ld -Ttext=0x20000000 -o add.elf add.o
$ arm-none-eabi-nm add.elf
... clip ...
20000000 t start
2000000c t stop
\end{verbatim}

\bigskip
Выходной файл, созданный \prog{ld}\ имеет формат, который называется
\termdef{ELF}{ELF}. Существует множество форматов, предназначенных для хранения
выполняемого и объектного кода\note{можно отдельно отметить Microsoft COFF
(объектные файлы .obj) и PE (.exe)cutable}. Формат ELF применяется для хранения
машинного кода, если вы запускаете его в базовой ОС\note{прежде всего
``большой''\ или встраиваемый \linux}, но поскольку мы собираемся запускать нашу
программу на bare metal\note{голом железе}, мы должны сконвертировать полученный
.elf файл в более простой \termdef{бинарный формат}{бинарный формат}.

Файл в \term{бинарном формате}\ содержит последовательность байт, начинающуюся с
определенного адреса памяти, поэтому бинарный файл еще 
называют \term{образом памяти}. Этот
формат типичен для утилит программирования флеш-памяти микроконтроллеров, так
как все что требуется сделать\ --- последовательно скопировать каждый байт из
файла в FlashROM-память микроконтроллера, начиная с определенного начального
адреса.\note{Та же операция выполняется и для SoC-систем с NAND-флешем:
записать бинарный образ начиная с некоторого аппаратно фиксированного адреса.}

Команда \gnut\ \prog{objcopy}\ используется для конвертирования машинного кода
между разными объектными форматами. Типичное использование:

\begin{verbatim}
$ objcopy -O <выходной_формат> <входной_файл> <выходной_файл>
\end{verbatim}

Конвертируем \file{add.elf}\ в бинарный формат:

\begin{verbatim}
$ objcopy -O binary add.elf add.bin
\end{verbatim}

Проверим размер полученного бинарного файла, он должен быть равен тем же 16
байтам\note{4 инструкции по 4 байта каждая}:

\begin{verbatim}
$ ls -al add.bin
-rw-r--r-- 1 vijaykumar vijaykumar 16 2008-10-03 23:56 add.bin
\end{verbatim}

Если вы не доверяете \prog{ls}, можно дизассемблировать бинарный файл:

\begin{verbatim}
ponyatov@bs:/tmp$ arm-none-eabi-objdump -b binary -m arm -D add.bin

add.bin:     file format binary

Disassembly of section .data:

00000000 <.data>:
   0:   e3a00005        mov     r0, #5
   4:   e3a01004        mov     r1, #4
   8:   e0812000        add     r2, r1, r0
   c:   eafffffe        b       0xc
ponyatov@bs:/tmp$ 
\end{verbatim}
Опция \verb|-b|\ задает формат файла, опция \verb|-m|\ (machine) архитектуру
процессора, получить полный список сочетаний \verb|-b/-m|\ можно командной
\verb|arm-none-eabi-objdump -i|.

\secrel{Выполнение в \qemu}

Когда ARM-процессор сбрасывается, он начинает выполнять команды с адрсе 0x0.
На плате Commnex установлен флеш на 16 мегабайт, начинающийся с адрес 0x0. Таким
образом, при сбросе будут выполняться инструкции с начала флеша.

Когда \qemu\ эмулирует плату connex, в командной строке должен быть указан файл,
который будет считаться образом флеш-памяти. Формат флеша очень прост\ --- это
побайтный образ флеша без каких-либо полей или заголовков, т.е. это тот же самый
\term{бинарный формат}, описанный выше.

Для тестирования программы в эмуляторе Gumstix connex, сначала мы создаем
16-мегабайтный файл флеша, копируя 16М нулей из файла \file{/dev/zero}\ с
помощью команды \prog{dd}. Данные копируются 4Кбайтными блоками\note{опция bs=
(blocksize)} (4096 х 4К):

\begin{verbatim}
$ dd if=/dev/zero of=flash.bin bs=4K count=4K
4096+0 записей получено
4096+0 записей отправлено
 скопировано 16777216 байт (17 MB), 0,0153502 c, 1,1 GB/c

$ du -h flash.bin 
16M     flash.bin
\end{verbatim}

Затем переписываем начало \file{flash.bin}\ копируя в него содержимое
\file{add.bin}:

\begin{verbatim}
$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
0+1 записей получено
0+1 записей отправлено
 скопировано 16 байт (16 B), 0,000173038 c, 92,5 kB/c
\end{verbatim}

После сброса процессор выполняет код с адреса 0x0, и будут выполняться
инструкции нашей программы. Команда запуска \qemu:

\begin{verbatim}
$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null

QEMU 2.1.2 monitor - type 'help' for more information
(qemu) 
\end{verbatim}

Опция \verb|-M connex|\ выбирает режим эмуляции: \qemu\ поддерживает эмуляцию
нескольких десятков вариантов железа на базе ARM процессоров. Опция \verb|-pflash|\
указывает файл образа флеша, который должен иметь определенный размер (16М).
\verb|-nographic|\ отключает эмуляцию графического дисплея (в отдельном окне).
Самая важная опция \verb|-serial /dev/null|\ подключает последовательный порт
платы на \file{/dev/null}, при этом в терминале после запуска \qemu\ вы получите
\emph{консоль монитора}.

\qemu\ выполняет инструкции, и останавливается в бесконечном цикле на
\var{stop}, выполняя команду \verb|stop: b stop|. Для просмотра содержимого
регистров процессора воспользуемся \termdef{монитором}{монитор \qemu}.
Монитор имеет интерфейс командной строки, который вы можете использовать для
контроля работы эмулируемой системы. Если вы запустите \qemu\ как указано выше,
монитор будет доступен через stdio.

Для просмотра регистров выполним команду \verb|info registers|:

\begin{verbatim}
(qemu) info registers
R00=00000005 R01=00000004 R02=00000009 R03=00000000
R04=00000000 R05=00000000 R06=00000000 R07=00000000
R08=00000000 R09=00000000 R10=00000000 R11=00000000
R12=00000000 R13=00000000 R14=00000000 R15=0000000c
PSR=400001d3 -Z-- A svc32
FPSCR: 00000000
\end{verbatim}

Обратите внимание на значения в регистрах r00..r02: 4, 5 и ожидаемый результат
9. Особое значение для ARM имеет регистр r15: он является указателем команд, и
содержит адрес текущей выполняемой машинной команды, т.е. \verb|0x000c: b stop|.

\secrel{Другие команды монитора}

Несколько полезных команд монитора:

\begin{tabular}{l l}
help & список доступных команд \\
quit & выход из эмулятора \\
xp /fmt addr & вывод содержимого физической памяти с адреса addr \\
system\_reset & перезапуск \\
\end{tabular}
\bigskip

Команда \verb|xp|\ требует некоторых пояснений. Аргумент \verb|/fmt|\ указывает
как будет выводиться содержимое памяти, и имеет синтаксис
\verb|<счетчик><формат><размер>|:

\begin{description}
\item[счетчик] число элементов данных
\item[size] размер одного элемента в битах: b=8 бит, h=16, w=32, g=64
\item[format] определяет формат вывода:
\begin{description}[nosep]
\item[x] hex
\item[d] десятичные целые со знаком
\item[u] десятичные без знака
\item[o] 8ричные
\item[c] символ (char)
\item[i] инструкции ассемблера
\end{description}
\end{description}

Команда \verb|xp|\ в формате \verb|i|\ будет дизассемблировать инструкции из
памяти. Выведем дамп с адреса 0x0 указав fmt=4iw: 4\ --- 4 , i\ ---
инструкции размером w=32 бита:

\begin{verbatim}
(qemu) xp /4wi 0x0
0x00000000:  e3a00005      mov  r0, #5  ; 0x5
0x00000004:  e3a01004      mov  r1, #4  ; 0x4
0x00000008:  e0812000      add  r2, r1, r0
0x0000000c:  eafffffe      b    0xc
\end{verbatim}

\secup
\secrel{Директивы ассемблера}\secdown

В этом разделе мы посмотрим несколько часто используемых директив ассемблера,
используя в качестве примера пару простых программ.

\secrel{Суммирование массива}\secdown

Следующий код \ref{kumarL2}\ вычисляет сумму массива байт и сохраняет результат
в \var{r3}:

\lstv{Сумма массива}{kumar/arrsum.s}\label{kumarL2}

В коде используются две новых ассемблерных директивы, описанных далее:
\verb|.byte|\ и \verb|.align|.

\secrel{\var{.byte}}

Аргументы директивы \verb|.byte|\ ассемблируются в последовательность байт в
памяти. Также существуют аналогичные директивы \verb|.2byte|\ и \verb|.4byte|\
для ассемблирования 16- и 32-битных констант:

\begin{verbatim}
.byte   exp1, exp2, ...
.2byte  exp1, exp2, ...
.4byte  exp1, exp2, ...
\end{verbatim}

Аргументом может быть целый числовой литерал: двоичный с префиксом 0b, 8-ричный
префикс 0, десятичный и hex 0x. Также может использоваться строковая константа в
одиночных кавычках, ассемблируемая в ASCII значения.

Также аргументом может быть \ci-выражение из литералов и других символов,
примеры:

\begin{verbatim}
pattern:  .byte 0b01010101, 0b00110011, 0b00001111
npattern: .byte npattern - pattern
halpha:   .byte 'A', 'B', 'C', 'D', 'E', 'F'
dummy:    .4byte 0xDEADBEEF
nalpha:   .byte 'Z' - 'A' + 1
\end{verbatim}

\secrel{\var{.align}}

Архитектура ARM требует чтобы инструкции находились в адресах памяти,
выровненных по границам 32-битного слова, т.е. в адресах с нулями в 2х младших
разрядах. Другими словами, адрес каждого первого байта из 4-байтной команды,
должен быть кратен 4. Для обеспечения этого предназначена директива
\verb|.align|, которая вставляет выравнивающие байты до следующего выровненного
адреса. Ее нужно использовать только если в код вставляются байты или неполные
32-битные слова.

\secup

\secrel{Вычисление длины строки}\secdown

Этот код вычисляет длину строки и помещает ее в \var{r1}:

\lstv{Длина строки}{kumar/strlen.s}

Код иллюстрирует применение директив \verb|.asciz|\ и \verb|.equ|.

\secrel{\var{.asciz}}

Директива \verb|.asciz|\ принимает аргумент: строковый литерал,
последовательность символов в двойных кавычках. Строковые литералы
ассемблируются в память последовательно, добавляя в конец нулевой символ
\verb|\0|\ (признак конца строки в языке \ci\ и стандарте POSIX).

Директива \verb|.ascii|\ аналогична \verb|.asciz|, но конец строки не
добавляется. Все символы\ --- 8-битные, кириллица может не поддерживаться.

\secrel{\var{.equ}}

Ассемблер при свой работе использует \termdef{таблицу символов}{таблица
символов}: она хранит соответствия меток и их адресов. Когда ассемблер встречает
очередное определение метки, он добавляет в таблицу новую запись. Когда
встречается упоминание метки, оно заменяется соответствующим адресом из
таблицы.

Использование директивы \verb|.equ|\ позволяет добавлять записи в
таблицу символов вручную, для привязки к именам любых числовых значений, не
обязательно адресов. Когда ассемблер встречает эти имена, они заменяются на их
значения. Эти имена-константы, и имена меток, называются
\termdef{сиволами}{символ}, а таблицы записанные в объектные файлы, или в
отдельные .sym файлы\ --- \termdef{таблицами символов}{таблица
символов}\note{также используются отладчиком, чтобы показывать адреса переходов
в виде понятных программисту сиволов, а не мутных числовых констант}.

Синтаксис директивы .equ:

\begin{verbatim}
.equ <имя>, <выражение>
\end{verbatim}

Имя символа имеет те же ограничения по используемым символам, что и метка.
Выражение может быть одиночным литералом или выражением как и в директиве
\verb|.byte|.

\begin{framed}
В отличие от .byte, директива .equ не выделяет никакой памяти под аргумент.
Она только добавляет значение в таблицу символов.  
\end{framed}

\secup

\secup
\secrel{Использование ОЗУ (адресного пространства процессора)}

Flash-память описанная ранее, в которой хранится машинный код программы, один из
видов EEPROM\note{Electrical Eraseable Programmable Read-Only Memory,
электрически стираемая перепрограммируемая память только-для-чтения}.
Это вторичный носитель данных, как например жесткий диск, но в
любом случае хранить данные и значения переменных во флеше неудобно как с точки
зрения возможности перезаписи, так и прежде всего со скоростью чтения флеша, и
кешированием.

В предыдущем примере мы использовали флеш как EEPROM для хранения константного
массива байт, но вообще переменные должны храниться в максимально быстрой и
неограниченно перезаписываемой RAM.

Плата connex имеет 64Mb ОЗУ начиная с адреса \verb|0xA0000000|, для хранения
данных программы. Карта памяти может быть представлена в виде диаграммы:

\fig{Карта памяти Gumstix connex}{kumar/memmap.png}{height=0.6\textheight}

\note{здесь адреса считаются сверху вниз, что нетипично, обычно на диаграммах
памяти адреса увеличиваются снизу вверх.}

Для настройки размещения переменных по нужным физическим адресам \emph{нужна}\
некоторая \emph{настройка адресного пространства}, особенно \emph{если вы
используете внешнюю память и переферийные устройства, подключемые к внешней
шине}\note{или используете малораспространенные клоны ARM-процессоров, типа
Миландровского 1986ВЕ9х ``чернобыль''}.

Для этого нужно понять, какую роль в распределении памяти играют ассемблер и
линкер.

\secrel{Линкер}\secdown

Линкер позволяет \termdef{скомпоновать}{компоновка}\ исполняемый файл программы
из нескольких объектных файлов, поделив ее на части. Чаще всего это нужно при
использовании нескольких компиляторов для разных языков программирования:
ассемблер, компиляторы \cpp, Фортрана и Паскакаля. 

Например, очень известная библиотека численных вычислений на базе матриц
BLAS/LAPACK написана на Фортране, и для ее использования с сишной программой
нужно слинковать program.o, blas.a и lapack.a\note{.a\ --- файлы архивов из пары
сотен отдельных .o файлов каждый, по одному .o файлу на каждый возможный вариант
функции линейной алгебры}\ в один исполняемый файл.

При написании многофайловой программы (еще это называют \termdef{инкрементной
компоновкой}{инкрементная компоновка}) каждый файл исходного кода ассемблируется
в индивидуальный файл объектного кода. Линкер\note{или компоновщик}\ собирает
объектные файлы в финальный исполняемый бинарник.

\bigskip
\fig{Роль линкера}{kumar/linkerrole.png}{height=0.25\textheight}
\bigskip

При сборке объектных файлов, линкер выполняет следующие операции:

\begin{itemize}[nosep]
  \item symbol resolution (разрешение символов)
  \item relocation (релокация) 
\end{itemize}

В этой секции мы детально рассмотрим эти операции.

\secrel{Разрешение символов}

В программе из одного файла при создании объектного файла все ссылки на метки
заменяются их адресами непосредственно ассемблером. Но в программе из нескольких
файлов существует множество ссылок на метки в других файлах, неизвестные на
момент ассемблирования/компиляции, и ассемблер помечает их ``unresolved''
(неразреш\'{е}нные). Когда эти объектные файлы обрабатываются линкером, он
определяет адреса этих меток по информации из других объектных файлов, и
корректирует код. Этот процесс называется \termdef{разрешением
символов}{разрешение символов}.

Пример суммирования массива разделен на два файла для демонстрации разрешения
символов, выполняемых линкером. Эти файлы ассемблируются отдельно, чтобы их
таблицы символов содержали неразрешенные ссылки.

Файл \file{sumsub.s}\ содержит процедуру суммирования, а \file{summain.s}\
вызывает процедуру с требуемыми аргументами:

\lstv{\file{summain.s}\ вызов внешней процедуры}{kumar/summain.s}
\lstv{\file{sumsub.s}\ код процедуры}{kumar/sumsub.s}
\note{в архитектуре ARM нет специальной команды возврата ret, ее функцию
выполняет прямое присваивание регистра указателя команд mov pc,lr} 

Применение директивы \verb|.global|\ обязательно. В \ci\ все функции и
переменные, определенные вне функций, считаются видимыми из других объектных
файлов, если они не определены с модификатором \verb|static|. В ассемблере
наоборот все метки считаются \term{статическими}\note{или локальными на уровне
файла}, если с помощью директивы \verb|.global|\ специально не указано, что они
должны быть видимы извне.

Ассемблируйте файлы, и посмотрите дамп их таблицы символов используя 
комунду \prog{nm}:

\begin{verbatim}
$ arm-none-eabi-as -o main.o main.s
$ arm-none-eabi-as -o sum-sub.o sum-sub.s
$ arm-none-eabi-nm main.o
00000004 t arr
00000007 t eoa
00000008 t start
00000018 t stop
         U sum 
$ arm-none-eabi-nm sum-sub.o
00000004 t loop
00000000 T sum
\end{verbatim}

Теперь сфокусируемся на букве во втором столбце, который указывает тип символа:
\verb|t|\ указывает что символ определен в секции кода \verb|.text|, \verb|u|\
указывает что символ не определен. Буква в верхнем регистре указывает что символ
глобальный и был указан в директиве \var{.global}.

Очевидно, что символ \var{sum}\ определ в \file{sum-sub.o}\ и еще не разрешен
в \file{main.o}. Вызов линкера разрешает символьные ссылки, и создает
исполняемый файл.
 
\secrel{Релокация}\secdown

\termdef{Релокация}{релокация символов}\ --- процесс изменения уже назначенных
меткам адресов.
Он также выполняет коррекцию всех ссылок, чтобы отразить заново назначенные
адреса меток. В общем, релокация выполняется по двум основным причинам:

\begin{enumerate}[nosep]
\item Объединение секций
\item Размещение секций
\end{enumerate}

Для понимания процеса релокации, нужно понимание самой концепции секций.

Код и данные отличаются по требованиям при исполнении. Например код может
размещаться в ROM-памяти, а данные требуют память открытую на запись. Очень
хорошо, если \emph{области кода и данных не пересекаются}. Для этого программы
делятся на секции. Большиство программ имеют как минимум две секции:
\var{.text}\ для кода и \var{.data}\ для данных. Ассемблерные директивы
\verb|.text|\ и \verb|.data|\ ожидаемо используются для переключения между этими
секциями.

Хорошо представить каждую секцию как ведро. Когда ассемблер натыкается на 
директиву секции, он начинает сливать код/данные в соответствующее ведро, так 
что они размещаются в смежных адресах. Эта диаграмма показывает как ассемблер
упорядочивает данные в секциях:

\fig{\\Секции}{../gnu-eprog/sections.png}{width=0.95\textwidth}

Теперь, когда у нас есть общее понимание
\termdef{секционирования}{секционирование}\ кода и данных, давайте посмотрим по
каким причинам выполняется релокация.

\secrel{Объединение секций}

Когда вы имеете дело с многофайловыми программами, секции в каждом объектном
файле имеют одинаковые имена (`.text`,\ldots), линкер отвечает за их объединение
в выполняемом файле. По умолчанию секции с одинаковыми именами из каждого
\file{.o}\ файла объединяются последовательно, и метки корректируются на новые
адреса.

Эффекты объединения секций можно посмотреть, анализируя таблицы символов
отдельно в объектных и исполняемом файлах. Многофайловая программа суммирования
может иллюстрировать объединение секций. Дампы таблиц символов:

\begin{verbatim}
$ arm-none-eabi-nm main.o
00000004 t arr
00000007 t eoa
00000008 t start
00000018 t stop
         U sum 
$ arm-none-eabi-nm sum-sub.o
00000004 t loop <1>
00000000 T sum
$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
$ arm-none-eabi-nm sum.elf
...
00000004 t arr
00000007 t eoa
00000008 t start
00000018 t stop
00000028 t loop <1>
00000024 T sum
\end{verbatim}
\begin{enumerate}
  \item символ \var{loop}\ имеет адрес \addr{0x4}\ в \file{sum-sub.o}, и
  \addr{0x28}\ в \file{sum.elf}, так как секция \var{.text}\ из
  \file{sum-sub.o}\ размещена сразу за секцией \var{.text}\ из \file{main.o}.
\end{enumerate}

\secrel{Размещение секций}

Когда программа ассемблируется, каждой секции назначается стартовый адрес
\addr{0x0}. Поэтому всем переменным назначаются адреса относитально начала
секции. Когда создается финальный исполнямый файл, секция размещаются по
некоторому адресу \addr{X}, и все адреса меток, назначенные в секции,
увеличиваются на \addr{X}, так что они указывают на новые адреса.

Размещение каждой секции по определенному месту в памяти и коррекцию всех ссылок
на метки в секции, выполняет линкер.

Эффект размещения секций можно увидеть по тому же дампу символов, описанному
выше. Для простоы используем объектный файл однофайловой программы суммирования
\file{sum.o}. Для увеличения заметности искуственно разместим секцию
\var{.text}\ по адресу \addr{0x100}:

\begin{verbatim}
$ arm-none-eabi-as -o sum.o sum.s
$ arm-none-eabi-nm -n sum.o
00000000 t entry <1>
00000004 t arr
00000007 t eoa
00000008 t start
00000014 t loop
00000024 t stop
$ arm-none-eabi-ld -Ttext=0x100 -o sum.elf sum.o <2>
$ arm-none-eabi-nm -n sum.elf
00000100 t entry <3>
00000104 t arr
00000107 t eoa
00000108 t start
00000114 t loop
00000124 t stop
...
\end{verbatim}

\begin{enumerate}[nosep]
\item Адреса меток назначаются с \addr{0}\ от начала секции.
\item Когда создается выполняемый файл, линкеру указано разместить секцию кода с 
адреса \addr{0x100}.
\item Адреса меток в \var{.text}\ переназначаются начиная с \addr{0x100}, и
все ссылки на метки корректируются.
\end{enumerate}

\bigskip
Процесс объединения и размещения секций в общем показаны на диаграмме:

\fig{\\Объединение и размещение
секций}{../gnu-eprog/relocation.png}{height=0.95\textheight}

\secup
\secup
\secrel{Скрипт линкера}\secdown

Как было описано в предыдущем разделе, объединение и размещение секций
выполняется линкером. Программист может контролировать этот процесс через
\termdef{скрипт линкера}{скрипт линкера}. Очень простой пример скрипта линкера:

\lstv{Простой скрипт линкера}{kumar/simple.lds}

\begin{enumerate}

\item Команда \var{SECTIONS}\ наиболее важная команда, она указывает как
секции объединяются, и по каким адресам они размещаются.

\item Внутри блока \var{SECTIONS}\ команда \var{.} (точка) представляет
\termdef{указатель адреса размещения}{указатель адреса размещения}. Указатель
адреса всегда инициализируется \addr{0x0}. Его можно модифицировать явно
присваивая новое значение. Показанная явная установка на \addr{0x0}\ на самом
деле не нужна.

\item Этот блок скрипта определяет что секция \var{.text}\ выходного файла
составляется из секций \var{.text}\ в файлах \file{abc.o}\ и \file{def.o},
причем именно в этом порядке.

\end{enumerate}

Скрипт линкера может быть значительно упрощен и универсализирован с помощью
использования символа шаблона \verb|*|\ вместо индивидуального указания имен
файлов:

\lstv{Шаблоны в скриптах линкера}{kumar/star.lds}

Если программа одновременно содержит секции `.text` и `.data`, объединение и 
размещение секций можно прописать вот так: 

\lstv{Несколько секций}{../gnu-eprog/code/sum-data.lds}

Здесь секция \var{.text}\ размещается по адресу \addr{0x0}, а секция
\var{.data}\ --- \addr{0x400}. Отметим, что если указателю размещения не
приваивать значения, секции \var{.text}\ и \var{.data}\ будут размещены в
смежных областях памяти.

\secrel{Пример скрипта линкера}

Для демонстрации использования скриптов линкера рассмотрим применение скрипта
\ref{linker1}\ для размещения секций \var{.text}\ и \var{.data}. Для этого
используем немного измененный пример программы суммирования массива, разделив
код и данные в отдельные секции:

\lstv{Программа суммирования массива}{../gnu-eprog/code/sum-data.s}

\begin{enumerate}
\item Изменения заключаются в выделении массива в секцию \var{.data}\ и
удалении директивы выравнивания \var{.align}.

\item Также не требуется инструкция перехода на метку \var{start}\ 
для обхода данных, так как линкер разместит секции отдельно. В результате
команды программы размещаются любым удобным способом, а скрипт линкера 
позаботится о правильном размещении сегментов в памяти.
 
\end{enumerate}

При линковке программы в командной строке нужно указать использования скрипта:

\begin{verbatim}
$ arm-none-eabi-as -o sum-data.o sum-data.s
$ arm-none-eabi-ld -T sum-data.lds -o sum-data.elf sum-data.o
\end{verbatim}

Опция \verb|-T sum-data.lds|\ указывает что используется скрипт
\file{sum-data.lds}. Выводим таблицу символов и видим размещение сегментов в
памяти:

\begin{verbatim}
$ arm-none-eabi-nm -n sum-data.elf
00000000 t start
0000000c t loop
0000001c t stop
00000400 d arr
00000403 d eoa
\end{verbatim}

Из таблицы символолов видно что секция \var{.text}\ размещена с адреса
\addr{0x0}, а секция \var{.data}\ c \addr{0x400}.

\secrel{Анализ объектного/исполняемого файла утилитой \prog{objdump}}

Более подробную информацию даст утилита \prog{objdump}:

\begin{verbatim}
$ arm-none-eabi-as -o sum-data.o sum-data.s
$ arm-none-eabi-ld -T sum-data.lds -o sum-data.elf sum-data.o
$ arm-none-eabi-objdump sum-data.elf
\end{verbatim}

\lstv{sum-data.objdump}{../gnu-eprog/code/sum-data.objdump}

\begin{enumerate}
\item указание на архитектуру, 

\item для которой предназначен исполняемый файл

\item стартовый адрес в секции \var{.text}, по умолчанию
\addr{0x0}\note{обязателен и фиксирован для прошивок микроконтроллеров, т.к. на
него перескакивает аппаратный сброс}

\item \termdef{ABI}{ABI}\ --- соглашения о передаче 

\item параметров в регистрах/стеке (для Си кода) 

\item приведена подробная информация о секциях

\item \var{.text}\ секция кода

\item \var{.data}\ секция данных

\item служебная информация

\item столбец \var{Size}\ указывает размер секции в байтах (hex)

\item \var{VMA}\note{Virtual Memory Address}\ указывает адрес размещения
сегмента

\item \var{Algn}\ (Align) автоматическое выравнивание содержимого сегмента в
памяти, в степени двойки \verb|2**n|: код выравнивается кратно \verb|2**2=4|\
байтам, данные не выравниваются \verb|2**0=1| 

\item Флаг \var{ALLOC}\ (Allocate) указывает что при загрузке программы под этот 
сегмент должна быть выделена память.

\item \var{LOAD}\ указывает что содержимое сегмента должно загружаться из
исполняемого файла в память при использовании ОС, а для микроконтроллеров
указывает программатору что сегмент нужно прошивать.

\item \var{READONLY}\ сегмент с константными неизменяемыми данными, которые
могут быть размещены в ROM, а при использовании ОС область памяти должна быть
помечена в таблице системы защиты памяти как R/O. Отсутствие флага
\var{READONLY}\ + наличие \var{LOAD}\ указывает что данные должны загружаться
\emph{только в ОЗУ}.

\item сегмент кода

\item сегмент данных

\item таблица символов

\item дизассемблированный код из секций, помеченных флагом \var{CODE}:
\var{.text}
 
\end{enumerate}

\secup
\secrel{Данные в RAM, пример}\secdown

Теперь мы знаем как писать скрипты линкера, и можем попытаться написать
программу, разместив данные в секции \var{.data}\ в ОЗУ.

Программа сложения модифицирована для загрузки значений из ОЗУ, и записи
результата обратно в ОЗУ: память для операндов и результат резмещена в секции
\var{.data}.

\lstv{Данные в ОЗУ}{../gnu-eprog/code/add-mem.s}

\lstv{Скрипт для линковки}{../gnu-eprog/code/flash-ram.lds}

Дамп таблицы символов:

\begin{verbatim}
$ arm-none-eabi-nm -n add-mem.elf
00000000 t start
0000001c t stop
a0000000 d val1
a0000001 d val2
a0000002 d result
\end{verbatim}

Срипт линкера решил проблему с размещением данных, но 
\emph{проблема с использованием ОЗУ еще не решена \,!}
 

\secrel{RAM энергозависима (volatile)\,!}

ОЗУ стирается при отключении питания, поэтому для использования ОЗУ недостаточно
разместить сегменты.

\begin{framed}
\emph{Во флеше должнен храниться}\ не только код, но \emph{и данные}, чтобы при
подаче питания специальный \termdef{startup код}{startup код}\ выполнил
\emph{инициалиацию ОЗУ}, копируя данные из флеша. Затем управление передается
основной программе.
\end{framed}

Поэтому секция \var{.data}\ имеет \emph{два адреса размещения}: 
\termdef{адрес хранения}{адрес хранения} во флеше \termdef{LMA}{LMA}\ и 
\termdef{адрес размещения}{адрес размещения} в ОЗУ \termdef{VMA}{VMA}.

TIP: как видно из раздела \ref{objdump}, в терминах \prog{ld}\ адрес
хранения (загрузки) называется \emph{LMA}\ (Load Memory Address), а адрес
размещения (времени выполнения) \emph{VMA}\ (Virtual Memory Address).

Нужно сделать следующие две мсодификации, чтобы программа работала корректно:

\begin{enumerate}
  \item модифицировать .lds чтобы для секции \var{.data}\ в нем учитывались оба
  адреса: LMA и VMA.
  \item написать небольшой кусочек кода, который будет \emph{инициализировать
  память данных}, копируя образ секции \var{.data}\ из флеша (из адреса хранения
  LMA) в ОЗУ (по адресу исполнения, VMA).
\end{enumerate}

\secrel{Спецификация адреса загрузки LMA}

VMA это адрес, который должен быть использован для вычисления адресов всех меток
при исполнении программы. В предыдущем линк-скрипте мы задали VMA секции
\var{.data}.
LDA не указан, и по умолчанию равен VMA. Это нормально для сегментов, 
размещаемых в ROM. Но если используются инициализируемые сегменты в ОЗУ, нужно
задать отдельно VMA и LMA.  

Адрес загрузки LMA, отличающийся от адреса выполнения VMA, задается с помощью
команды \verb|AT|. Модифицированный скрипт показан ниже:

\begin{verbatim}
SECTIONS {
	. = 0x00000000;
	.text : { * (.text); }
	etext = .; <1>

	. = 0xA0000000;
	.data : AT (etext) { * (.data); } <2>
}
\end{verbatim}

\begin{enumerate}
  \item 
В блоках описания секций можно создавать символы, назначая им значения:
числовой адрес или текущую позицию с помощью точки ".". Символу \var{etext}\
назначается адрес флеша, следующий сразу за концом кода. Отметим что
\var{etext}\ сам по себе не выделяет никакой памяти, а только помечает адрес LMA
сегмента .data в таблице символов.

  \item 
При настройке сегмента \var{.data}\ с помощью ключевого слова
\verb|AT (etext)|\ назначается LMA для хранения содержимого сегмента данных.
Команде \var{AT}\ может быть передан любой адрес или символ\note{значением которого
является валидный адрес}. Так что в результате мы настроили адрес хранения 
\var{.data}\ на область флеша, помеченную символов \var{etext}.

\end{enumerate}

\secrel{Копирование `.data` в ОЗУ}

Для копирования данных инициализации из флеша в ОЗУ требуется следующая 
информация: 

\begin{enumerate}[nosep]
  \item 
  Адрес данных во флеше (\var{flash\_sdata})
  \item 
  Адрес данных в ОЗУ (\var{ram\_sdata})
  \item 
  Размер секции \var{.data}\ (\var{data\_size})
\end{enumerate}

Имея эту информацию, сегмент \var{.data}\ может быть инициализирован
может быть скопирован следующим стартовым кодом:

\begin{verbatim}
	ldr   r0, =flash_sdata
	ldr   r1, =ram_sdata
	ldr   r2, =data_size
copy:	
	ldrb  r4, [r0], #1
	strb  r4, [r1], #1
	subs  r2, r2, #1
	bne   copy
\end{verbatim}

Для получения такой информации скрипт линкера нужно немного модифицировать:

\lstv{Скрипт линкера с символами для копирования секции
\var{.data}}{kumar/ramcopy.lds}

\begin{enumerate}
  \item 
Начало данных во флеше сразу за секцией кода.
  \item 
Начало данных\ --- базовый адрес ОЗУ в адресном пространстве процессора.
  \item 
Получение размера непросто: размер вычисляется вычитанием адресов
метод начала и конца данных. Да, простые выражения тоже можно использовать в
скрипте линкера.
\end{enumerate}

Полный листинг программы с добавленной инициализацией данных:

\lstv{Инициализация ОЗУ}{../gnu-eprog/code/add-ram.s}

\lstv{\file{add-ram.objdump}}{../gnu-eprog/code/add-ram.objdump}

Программа была ассемблирована и слинкована используя .lds в \ref{linker2}.

Запуск и тестирование программы в Qemu:

\begin{verbatim}
qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
(qemu) xp /4dw 0xA0000000
a0000000:         10         30         40          0
\end{verbatim}

\begin{framed}
На реальной физической системе с SDRAM, память не может использована 
сразу. Сначала нужно инициализировать контроллер памяти, и только затем
обращаться к ОЗУ. Наш код работает потому, что симулятор не требует
инициализации контроллера.
\end{framed}

\secup

\secrel{Обработка аппаратных исключений}

Все примеры программ, приведенные выше, содержат гигантский баг: \emph{первые
8 машинных слов в адресном пространстве зарезервированы для векторов
исключений}. Когда возникает исключение, выполняется аппаратный переход
на один из этих жестко заданных меток. Исключения и их адреса приведены
в следующей таблице:

\paragraph{Адреса векторов исключений\\}

\begin{tabular}{l l l}
Исключение && Адрес \\
\hline
 Сброс & Reset                   & 0x00 \\
 Неопределенная инструкция & Undefined Instruction	  & 0x04 \\
 Программное прерывание (SWI) & Software Interrupt (SWI)& 0x08 \\
 Ошибка предвыборки & Prefetch Abort	  & 0x0C \\
 Ошибка данных & Data Abort		  & 0x10 \\
 Резерв, не используется & Reserved, not used	  & 0x14 \\
 Аппаратное прерывание & IRQ			  & 0x18 \\
 Быстрое прерывание & FIQ			  & 0x1C \\
\end{tabular}

Предполагается что по этим адресам находятся команды перехода, которые
передадут управление на соответствующий произвольный адрес обработчика
исключения. Во всех примерах ранее бы не вставляли таблицу обработчиков
исключений, так как мы предполагали что эти исключения не случатся. Все
эти программы можно скорректировать, слинковав их со следующим кодом:  

\begin{verbatim}
	.section "vectors"
reset:	b     start
undef:  b     undef
swi:	b     swi
pabt:	b     pabt
dabt:	b     dabt
	nop
irq:	b     irq
fiq:	b     fiq
\end{verbatim}

Только обработчик \var{reset}\ векторизован на отдельный адрес \var{start}. Все
остальные исключения векторизованы сами на себя. Таким образом если случится любое
исключение, процессор зациклится на соответствущем векторе. В этом случае
возникшее исключение может быть идентифицирвовано в отладчике (мониторе Qemu,
в нашем случае) по адресу указателя команд \var{pc=r15}.

В ассемблерном коде видно применение директивы \var{.section}\ которая позволяет
создавать секции с произвольными именами, чтобы прописать для них отдельную
обработку в скрипте линкера.

Чтобы обеспечить правильное размещение таблицы обработчиков, нужно
скорректировать скрипт линкера: 

\begin{verbatim}
SECTIONS {
	. = 0x00000000;
	.text : {
		* (vectors);
		* (.text); 
		...
	}
	...
}
\end{verbatim}

Обратите внимание что секция \var{vectors}\ размещена сразу за инициализацией
указателя размещения на первом месте, до всего остального кода, что гарантирует
что таблица векторов будет находится по жесткому адресу \verb|0x0|.


\secrel{Стартап-код на \ci}\secdown

Если процесс только что был сброшен, невозможно напрямую выполниь \ci-код,
так как в отличие от ассемблера, программы на \ci\ требуют для себя некоторой
предварительной настройки. В этом разделе описаны эти предварительные требования,
и как их выполнить.

Мы возьмем пример \ci-программы которая вычисляет сумму массива. И к концу
раздела мы уже будем способны, сделав некоторые низкоуровневые
настройки, передать управление и выполнить ее.

\lstv{Сумма массива на Си}{../gnu-eprog/code/csum.c}

Перед передачей управления \ci-коду, нужно выполнить следующие настройки:

\begin{enumerate}[nosep]
\item
  Стек
\item
  Глобальные переменные
  \begin{enumerate}[nosep]
    \item 
    Инициализированные
    \item 
    Неинициализированные
  \end{enumerate}
\item
  Константные данные
\end{enumerate}

\secrel{Стек}

\ci\ использует стек для хранения локальных (авто) переменных, передачи
аргументов и результата функций, хранения адресов возврата из функций и т.д.
Так что  необходимо чтобы стек был настроен корректно перед передачей управление
\ci-коду.

На архитектуре ARM стеки очень гибкие, поэтому их реализация польностью ложиться
на программное обеспечение. Для людей не знакомых с ARM, некоторый обзор приведен
в \ref{arm-stacks}.

Чтобы быть уверенным, что разные части кода, сгенерированного \emph{разными}\ 
компиляторами, работали друг с другом, ARM создал 
\href{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042a/IHI0042A\_aapcs.pdf}{Стандарт
вызова процедур для архитектуры ARM (AAPCS)}. В нем описаны регистры которые 
должны быть использованы для работы со стеком и направление в котором растет
стек. Согласно AAPCS, \emph{регистр \var{r13}}\ должен быть использован для
указателя стека. Также стек должен быть для указателя стека. Также стек должен быть
\emph{full-descending}\ (нисходящим).

Один из способов размещения глобальных переменных на стеке показан в диаграмме:

\fig{Размещение стека}{../gnu-eprog/stack.png}{height=0.6\textheight}

Так что все, что нужно сделать в стартовом коде для стека\ --- выставить
\var{r13}\ на старший адрес ОЗУ, так что стек может расти вниз (в сторону
младших адресов).
Для платы \var{connex}\ это можно сделать командой  

\begin{verbatim}
	ldr sp, =0xA4000000
\end{verbatim}

Обратите внимание что ассемблер предоставляет алиас \var{sp}\ для регистра
\var{r13}.

\begin{framed}
Адрес \var{0xA4000000}\ сам по себе не указывает на ОЗУ. ОЗУ кончается адресом
\var{0xA3FFFFFF}. Но это нормально, так как стек 
\emph{full}-descending, т.е. во время первого \var{push}\ в стек указатель
\emph{сначала уменьшится}, и только потом значение будет записано уже в ОЗУ.
\end{framed}

\secrel{Глобальные переменные}

Когда компилируется \ci-код, компилятор размещает инициализированные
глобальные переменные в секцию \var{.data}. Как и для ассемблера, сегмент
\var{.data}\ должен быть скопирован стартовым кодом в ОЗУ из флеша.

Язык \ci\ гарантирует что все неинициализированные глобальные переменные будут
инициализированы нулем\note{старый стандарт \ci\ не гарантировал}. Когда
\ci-программа компилируется, создается отдельный сегмент \var{.bss}\ для
неинициализированных переменных. Так как для всего сегмента должно быть
выполнено обнуление, его не нужно хранить во флеше. Перед передачей управления
на \ci-код, содержимое \var{.bss}\ дожно быть зачищено startup-кодом.

\secrel{Константные данные}

GCC размещает переменные, помеченные модификатором \var{const}, в отдельный
сегмент \var{.rodata}. Также \var{.rodata}\ используется для хранения всех
"строковых констант".

Так как содержимое \var{.rodata}\ не модифицируется, оно может быть размещено в
Flash/ROM. Для этого нужно модифицировать .lds.

\secrel{Секция \var{.eeprom}\ (AVR8)}

При написании прошивок для Atmel AVR8, существует модификатор \var{EEMEM}\
определенный в \file{avr/eeprom.h}:

\begin{verbatim}
#define EEMEM __attribute__((section(".eeprom")))
\end{verbatim}

который использует модификатор GCC \verb|__attribute__((section("...")))|,
который приписывает объект данных к любой указанной секции. В частности, 
секция \var{.eeprom}\ выделяется из финального объектного файла, и
программируется в Atmel ATmega отдельным вызовом \var{avrdude}\ (ПО
программатора).

\secrel{Стартовый код}

Теперь все готово к написанию скрипта линкера и стартового кода.
Скрипт \ref{linker2}\ модифицируется с добавлением размещения секций:

\begin{enumerate}[nosep]
  \item 
  \var{.bss}
  \item 
  \var{vectors}
  \item 
  \var{.rodata}
\end{enumerate}

Секция \var{.bss}\ размещается сразу за секцией \var{.data}\ в ОЗУ. Также
создаются символы маркирующие начало и конец секции \var{.bss}, которые будут
использованы в startup-коде при ее очистке. \var{.rodata}\ размещается сразу
за \var{.text}\ во флеше:

\fig{\\Размещение секций}{../gnu-eprog/csections.png}{width=0.7\textwidth}

\lstv{Скрипт линкера для \ci\ кода}{../gnu-eprog/code/csum.lds}

Startup-код включает следующие части:

\begin{enumerate}[nosep]
  \item 
    вектора исключений
  \item 
    код копирования \var{.data}\ из Flash в RAM
  \item 
    код обнуления \var{.bss}
  \item 
    код установки указателя стека
  \item 
    переход на \verb|_main|
\end{enumerate}

\lstv{Стартовый код для \ci\ программы на
ассемблере}{../gnu-eprog/code/startup.s}

Для компиляции кода не требуется отдельно вызывать ассемблер, линкер и
компилятор \ci: программа \prog{gcc}\ является оберткой, которая умеет делать
это сама, автоматически вызывая ассемблер, компилятор и линкер в зависимости от
типов файлов. Поэтому мы можем скомпилировать весь наш код одной командой:

\begin{verbatim}
$ arm-none-eabi-gcc -nostdlib -o csum.elf -T csum.lds csum.c startup.s
\end{verbatim}

Опция \verb|-nostdlib|\ используется для указания, что нам при компиляции
не нужно подключать стандартную библиотеку \ci\ (\prog{newlib}). Эта библиотека
крайне полезна, но для ее использования нужно выполнить некоторые дополнительные
действия, описанные в разделе \ref{c-library}.

Дамп таблицы символов даст больше информации о расположении объектов в памяти:

\begin{verbatim}
$ arm-none-eabi-nm -n csum.elf
00000000 t reset	<1>
00000004 A bss_size
00000004 t undef
00000008 t swi
0000000c t pabt
00000010 t dabt
00000018 A data_size
00000018 t irq
0000001c t fiq
00000020 T main
00000090 t start	<2>
000000a0 t copy
000000b0 t init_bss
000000c4 t zero
000000d0 t init_stack
000000d8 t stop
000000f4 r n		<3>
000000f8 A flash_sdata
a0000000 d arr		<4>
a0000000 A ram_sdata
a0000018 A ram_edata
a0000018 A sbss
a0000018 b sum		<5>
a000001c A ebss
\end{verbatim}

\begin{enumerate}
  \item 
\var{reset}\ и остальные вектора исключений размещаются с \addr{0x0}.
  \item 
ассемблерный код находится сразу после 8 векторов исключений 
    \verb|( 8 * 4 = 32 = 0x20 )|.
  \item 
константные данные \var{n}, размещены во флеше после кода.
  \item 
инициализированные данные \var{arr}, массив из 6 целых, размещен
    с начала ОЗУ \addr{0xA0000000}.
  \item 
неинициализированные данные \var{sum}\ размещен после массива из 6 целых.
    \verb|( 6 * 4 = 24 = 0x18 )|
\end{enumerate}

Для выполнения программы преобразуем ее в \var{.bin}\ формат, запустим в
\qemu, и выведем дамп переменной \var{sum}\ по адресу \addr{0xA0000018}:

\begin{verbatim}
$ arm-none-eabi-objcopy -O binary csum.elf csum.bin
$ dd if=/dev/zero of=flash.bin bs=4K count=4K
$ dd if=csum.bin of=flash.bin bs=4096 conv=notrunc
$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
(qemu) xp /6dw 0xa0000000
a0000000:          1         10          4          5
a0000010:          6          7
(qemu) xp /1dw 0xa0000018
a0000018:         33
\end{verbatim}

\secup
\secrel{Использование библиотеки \ci} FIXME: Эту секцию еще нужно написать.
\secrel{Inline-ассемблер} FIXME: Эту секцию еще нужно написать.
\secrel{13. Contributing}
\secrel{14. Credits}\secdown
\secrel{14.1. People}
\secrel{14.2. Tools}
\secup
\secrel{15. Tutorial Copyright}
\secrel{A. ARM Programmer’s Model}
\secrel{B. ARM Instruction Set}\label{kumarB}
\secrel{C. ARM Stacks}
 
\secup 
