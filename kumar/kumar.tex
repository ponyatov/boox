\secrel{Embedded-программирование с использованием \gnut\
\cite{kumar}}\label{kumaru}\secdown \copyright\ Vijay Kumar B.\\
\cp{http://bravegnu.org/gnu-eprog/}

\secrel{Введение}

GNU toolchain широко используется при разработки программного обеспечения для
встраиваемых систем. Этот тип разработки ПО также называют
\termdef{низкоуровневым программированием}, \termdef{standalone}{standalone}\
или \termdef{bare metal}{bare metal}\ программированием (на Си и \cpp).
Написание низкоуровневого кода на \cpp\ добавляет программисту новых проблем,
требующих глубокого понимания инструмента разработчика\ --- \gnut.
Руководства разработчика \gnut\ предоставляют отличную информацию по
инструментарию, но с точки зрения самого \gnut, чем с точки зрения решаемой
проблемы. Поэтому было написано это руководство, в котором будут описаны
типичные проблемы, с которыми сталкивается начинающий разработчик.

Этот учебник стремится занять свое место, объясняя использование \gnut\ с точки
зрения практического использования. Надеемся, что его будет достаточно для
разработчиков, собирающихся освоить и использовать \gnut\ в их embedded
проектах.

В иллюстративных целях была выбрана встроенная система на базе процессорного
ядра ARM, которая эмулируется в пакете \qemu. С таким подходом вы сможете
освоить \gnut\ с комфортом на вашем рабочем компьютере, без необходимости
вкладываться в ``физическое''\ железо, и бороться со сложностями с его запуском.
Учебник не стремиться обучить работе с архитектурой ARM, для этого вам нужно
будет воспользоваться дополнительными книгами или онлайн-учебниками типа:

\begin{itemize}[nosep]
  \item ARM Assembler\ \url{http://www.heyrick.co.uk/assembler/}
  \item ARM Assembly Language Programming\
  \url{http://www.arm.com/miscPDFs/9658.pdf}
\end{itemize}

Но для удобства читателя, некоторое множество часто используемых ARM-инструкций
описано в приложении \ref{kumarB}.

\secrel{Настройка тестового стенда}\secdown

В этом разделе описано, как настроить на вашей рабочей станции простую среду
разработки и тестирования ПО для платформы ARM, используя \qemu\ и \gnut.
\qemu\ это программный\note{для i386\ --- программно-аппаратный, использует
средства виртуализации хост-компьютера} эмулятор нескольких распространенных
аппаратных платформ. Вы можете написать программу на ассемблере и \cpp,
скомпилировать ее используя \gnut\ и отладить ее в эмуляторе \qemu.

\secrel{\qemu\ ARM}

Будем использовать \qemu\ для эмуляции отладочной платы \prog{Gumstix}\ на базе
процессора PXA255. Для работы с этим учебником у вас должен быть установлен
\qemu\ версии не ниже 0.9.1.

Процессор\note{Точнее SoC: система-на-кристалле}\ PXA255 имеет ядро ARM c
набором инструкций ARMv5TE. PXA255 также имеет в своем составе несколько блоков
периферии. Некоторая периферия будет описана в этом курсе далее.

\secrel{Инсталляция \qemu\ на \debian}

Этот учебник требует \qemu\ версии не ниже 0.9.1. Пакет \qemu\ доступный для
современных дистрибутивов \debian, вполне удовлетворяет этим условиям, и
собирать свежий \qemu\ из исходников совсем не требуется\note{хотя может быть и
очень хочется}. Установим пакет командой:

\begin{verbatim}
$ sudo apt install qemu
\end{verbatim}

\secrel{Установка кросс-компилятора \gnut\ для ARM}

Если вы предпочитаете простые пути, установите пакет кросс-компилятора командной

\begin{verbatim}
sudo apt install gcc-arm-none-eabi
\end{verbatim}

или

\begin{enumerate}
  \item Годные чуваки из CodeSourcery\note{подразделение Mentor
  Graphics}\ уже давно запилили несколько вариантов \gnut ов для разных ходовых
  архитектур. Скачайте готовую бинарную бесплатную lite-сборку
  \href{http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/}{\gnut-ARM}
  
\item Распакуйте tar-архив в каталог \dir{~/toolchains}:

\begin{verbatim}
$ mkdir ~/toolchains
$ cd ~/toolchains
$ tar -jxf ~/downloads/arm-2008q1-126-arm-none-eabi-i686-pc-linux-gnu.tar.bz2
\end{verbatim}

  \item Добавьте bin-каталог тулчейна в переменную среды \var{PATH}.

\begin{verbatim}
$ PATH=$HOME/toolchains/arm-2008q1/bin:$PATH 
\end{verbatim}

\item Чтобы каждый раз не выполнять предыдущую команду, вы можете прописать
ее в дот-файл \file{.bashrc}.

\end{enumerate}

Для совсем упертых подойдет рецепт сборки полного комплекта кросс-компилятора из
исходных тектов, описанный в \ref{cross}.

\secup
\secrel{Hello ARM}\secdown

В этом разделе вы научитесь пользоваться arm-ассемблером, и тестировать вашу
программу на голом железе\ --- эмуляторе платы \prog{connex}/\qemu.

Файл исходника ассемблерной программы состоит из последовательности инструкций,
по одной на каждую строку. Каждая инструкция имеет формат (каждый
компонент не обязателен):

\begin{verbatim}
<метка>:    <инструкция>         @ <комментарий>
\end{verbatim}

\begin{description}
\item[метка]\ --- типичный способ пометить адрес инструкции в памяти. Метка
может быть использована там, где требуется указать адрес, например как операнд
в команде перехода. Метка может состоять из латинских букв, цифр\note{не может
быть первым символом метки}, символов \verb|_|\ и \verb|$|.
\item[инструкция]\ может быть инструкцией процессора или директивой ассемблера,
начинающейся с точки ``.''
\item[комментарий]\ начинается с символа \verb|@|\ --- все последующие символы
игнориуются до конца строки
\end{description}

Вот пример простой ассемблерной программы для процессора ARM, складывающей
два числа:

\begin{lstlisting}[title=Листинг 1: Сложение чисел]
        .text
start:                       @ Label, not really required
        mov   r0, #5         @ Load register r0 with the value 5
        mov   r1, #4         @ Load register r1 with the value 4
        add   r2, r1, r0     @ Add r0 and r1 and store in r2

stop:   b stop               @ Infinite loop to stop execution
\end{lstlisting}

метка необязательна

загрузить в регистр r0 значение 5

загрузить в регистр r1 значение 4

сложить r0+r1 и сохранить в r2

пустой бесконечный цикл для останова выполнения

\bigskip

\verb|.text|\ ассемблерная директива, указывающая что последующий код должен
быть \term{ассемблирован}\ в \termdef{секцию кода \var{.text}}, а не в секцию
\var{.data}. \term{Секции}\ будут подробно описаны далее.

\secrel{Сборка бинарника}

Save the program in a file say add.s. To assemble the file, invoke the GNU Toolchain’s assembler as, as shown in the following command.



\secrel{3.2. Executing in Qemu}
\secrel{3.3. More Monitor Commands}
\secup
\secrel{4. More Assembler Directives}\secdown
\secrel{4.1. Sum an Array}
\secrel{4.2. String Length}
\secup
\secrel{5. Using RAM}
\secrel{6. Linker}\secdown
\secrel{6.1. Symbol Resolution}
\secrel{6.2. Relocation}
\secup
\secrel{7. Linker Script File}\secdown
\secrel{7.1. Linker Script Example}
\secup
\secrel{8. Data in RAM, Example}\secdown
\secrel{8.1. RAM is Volatile!}
\secrel{8.2. Specifying Load Address}
\secrel{8.3. Copying .data to RAM}
\secup
\secrel{9. Exception Handling}
\secrel{10. C Startup}\secdown
\secrel{10.1. Stack}
\secrel{10.2. Global Variables}
\secrel{10.3. Read-only Data}
\secrel{10.4. Startup Code}
\secup
\secrel{11. Using the C Library}
\secrel{12. Inline Assembly}
\secrel{13. Contributing}
\secrel{14. Credits}\secdown
\secrel{14.1. People}
\secrel{14.2. Tools}
\secup
\secrel{15. Tutorial Copyright}
\secrel{A. ARM Programmer’s Model}
\secrel{B. ARM Instruction Set}\label{kumarB}
\secrel{C. ARM Stacks}
 
\secup 