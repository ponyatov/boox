\secrel{Embedded-программирование с использованием \gnut\
\cite{kumar}}\label{kumaru}\secdown \copyright\ Vijay Kumar B.\\
\cp{http://bravegnu.org/gnu-eprog/}

\secrel{Введение}

GNU toolchain широко используется при разработки программного обеспечения для
встраиваемых систем. Этот тип разработки ПО также называют
\termdef{низкоуровневым программированием}, \termdef{standalone}{standalone}\
или \termdef{bare metal}{bare metal}\ программированием (на Си и \cpp).
Написание низкоуровневого кода на \cpp\ добавляет программисту новых проблем,
требующих глубокого понимания инструмента разработчика\ --- \gnut.
Руководства разработчика \gnut\ предоставляют отличную информацию по
инструментарию, но с точки зрения самого \gnut, чем с точки зрения решаемой
проблемы. Поэтому было написано это руководство, в котором будут описаны
типичные проблемы, с которыми сталкивается начинающий разработчик.

Этот учебник стремится занять свое место, объясняя использование \gnut\ с точки
зрения практического использования. Надеемся, что его будет достаточно для
разработчиков, собирающихся освоить и использовать \gnut\ в их embedded
проектах.

В иллюстративных целях была выбрана встроенная система на базе процессорного
ядра ARM, которая эмулируется в пакете \qemu. С таким подходом вы сможете
освоить \gnut\ с комфортом на вашем рабочем компьютере, без необходимости
вкладываться в ``физическое''\ железо, и бороться со сложностями с его запуском.
Учебник не стремиться обучить работе с архитектурой ARM, для этого вам нужно
будет воспользоваться дополнительными книгами или онлайн-учебниками типа:

\begin{itemize}[nosep]
  \item ARM Assembler\ \url{http://www.heyrick.co.uk/assembler/}
  \item ARM Assembly Language Programming\
  \url{http://www.arm.com/miscPDFs/9658.pdf}
\end{itemize}

Но для удобства читателя, некоторое множество часто используемых ARM-инструкций
описано в приложении \ref{kumarB}.

\secrel{Настройка тестового стенда}\secdown

В этом разделе описано, как настроить на вашей рабочей станции простую среду
разработки и тестирования ПО для платформы ARM, используя \qemu\ и \gnut.
\qemu\ это программный\note{для i386\ --- программно-аппаратный, использует
средства виртуализации хост-компьютера} эмулятор нескольких распространенных
аппаратных платформ. Вы можете написать программу на ассемблере и \cpp,
скомпилировать ее используя \gnut\ и отладить ее в эмуляторе \qemu.

\secrel{\qemu\ ARM}

Будем использовать \qemu\ для эмуляции отладочной платы \prog{Gumstix}\ на базе
процессора PXA255. Для работы с этим учебником у вас должен быть установлен
\qemu\ версии не ниже 0.9.1.

Процессор\note{Точнее SoC: система-на-кристалле}\ PXA255 имеет ядро ARM c
набором инструкций ARMv5TE. PXA255 также имеет в своем составе несколько блоков
периферии. Некоторая периферия будет описана в этом курсе далее.

\secrel{Инсталляция \qemu\ на \debian}

Этот учебник требует \qemu\ версии не ниже 0.9.1. Пакет \qemu\ доступный для
современных дистрибутивов \debian, вполне удовлетворяет этим условиям, и
собирать свежий \qemu\ из исходников совсем не требуется\note{хотя может быть и
очень хочется}. Установим пакет командой:

\begin{verbatim}
$ sudo apt install qemu
\end{verbatim}

\secrel{Установка кросс-компилятора \gnut\ для ARM}

Если вы предпочитаете простые пути, установите пакет кросс-компилятора командной

\begin{verbatim}
sudo apt install gcc-arm-none-eabi
\end{verbatim}

или

\begin{enumerate}
  \item Годные чуваки из CodeSourcery\note{подразделение Mentor
  Graphics}\ уже давно запилили несколько вариантов \gnut ов для разных ходовых
  архитектур. Скачайте готовую бинарную бесплатную lite-сборку
  \href{http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/}{\gnut-ARM}
  
\item Распакуйте tar-архив в каталог \dir{~/toolchains}:

\begin{verbatim}
$ mkdir ~/toolchains
$ cd ~/toolchains
$ tar -jxf ~/downloads/arm-2008q1-126-arm-none-eabi-i686-pc-linux-gnu.tar.bz2
\end{verbatim}

  \item Добавьте bin-каталог тулчейна в переменную среды \var{PATH}.

\begin{verbatim}
$ PATH=$HOME/toolchains/arm-2008q1/bin:$PATH 
\end{verbatim}

\item Чтобы каждый раз не выполнять предыдущую команду, вы можете прописать
ее в дот-файл \file{.bashrc}.

\end{enumerate}

Для совсем упертых подойдет рецепт сборки полного комплекта кросс-компилятора из
исходных тектов, описанный в \ref{cross}.

\secup
\secrel{Hello ARM}\secdown

В этом разделе вы научитесь пользоваться arm-ассемблером, и тестировать вашу
программу на голом железе\ --- эмуляторе платы \prog{connex}/\qemu.

Файл исходника ассемблерной программы состоит из последовательности инструкций,
по одной на каждую строку. Каждая инструкция имеет формат (каждый
компонент не обязателен):

\begin{verbatim}
<метка>:    <инструкция>         @ <комментарий>
\end{verbatim}

\begin{description}
\item[метка]\ --- типичный способ пометить адрес инструкции в памяти. Метка
может быть использована там, где требуется указать адрес, например как операнд
в команде перехода. Метка может состоять из латинских букв, цифр\note{не может
быть первым символом метки}, символов \verb|_|\ и \verb|$|.
\item[инструкция]\ может быть инструкцией процессора или директивой ассемблера,
начинающейся с точки ``.''
\item[комментарий]\ начинается с символа \verb|@|\ --- все последующие символы
игнориуются до конца строки
\end{description}

Вот пример простой ассемблерной программы для процессора ARM, складывающей
два числа:

\lstv{Листинг 1: Сложение чисел}{kumar/add.s}

\verb|.text|\ ассемблерная директива, указывающая что последующий код должен
быть \term{ассемблирован}\ в \termdef{секцию кода \var{.text}}, а не в секцию
\var{.data}. \term{Секции}\ будут подробно описаны далее.

\secrel{Сборка бинарника}

Сохраните программу в файл \file{add.s}\ \note{.s или .S стандарное расширение в
мире \linux, указывает что это файл с программной на ассемблере}.
Для ассемблирования файла вызовите ассемблер \prog{as}:

\begin{verbatim}
$ arm-none-eabi-as -o add.o add.s
\end{verbatim}

Опция \verb|-o|\ указывает выходной файл с \termdef{объектным кодом}{объектный
код}, имеющий стандартное расширение \verb|.o|\note{и внутренний формат ELF (как
завещал великий \linux)}.

\begin{framed}
\noindent Команды кросс-тулчейна всегда имеют префикс целевой архитектуры
(target triplet), для которой они были собраны, чтобы предотвратить
конфликт имен с хост-тулчейном для вашего рабочего компьютера. Далее утилиты
\gnut\ будут использоваться без префикса для лучшей читаемости. \emph{не
забывайте добавлять \prog{arm-none-eabi-}, иначе получите множество странных
ошибок типа ``unexpected command''}.
\end{framed}

\begin{verbatim}
$ (arm-none-eabi-)as -o add.o add.s
$ (arm-none-eabi-)objdump -x add.o
\end{verbatim}
\lstx{вывод команды \prog{arm-none-eabi-objdump\ -x}:  
ELF-заголовки в файле объектного кода}{kumar/add.objdump}

сейкция \var{.text}\ имеет размер \verb|Size=0x0010|\ =16 байт, и содержит
\emph{машинный код}:

\lstx{машинный код из секции \var{.text}: \prog{objdump -d}}{kumar/add.disasm}

\bigskip
Для генерации \emph{исполняемого файла}\note{обычно тот же формат ELF.o,
слепленный из одного или нескольких объектных файлов, с некоторыми
модификациями см. опцию -T далее}\ вызовем \termdef{линкер}{линкер}\ \prog{ld}:

\begin{verbatim}
$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o
\end{verbatim}

Опять, опция \verb|-o|\ задает выходной файл. \verb|-Ttext=0x0|\ явно указывает
адрес, от которого будут отсчитываться все метки, т.е. секция инструкций
начинается с адреса \verb|0x0000|. Для просмотра адресов, назначенных меткам,
можно использовать команду \verb|(arm-none-eabi-)nm|\ \note{NaMes}:

\begin{verbatim}
ponyatov@bs:/tmp$ arm-none-eabi-nm add.elf
...
00000000 t start
0000000c t stop
\end{verbatim}
* если вы забудете опцию -T, вы получите этот вывод с адресами \verb|00008xxx|\
--- эти адреса были заданы при компиляции \gnut-ARM, и могут не совпадать
с необходимыми вам. Проверяйте ваши .elfы с помощью \prog{nm}\ или
\prog{objdump}, если программы не запускаются, или \qemu\ ругается на ошибки
(защиты) памяти.
\bigskip

Обратите внимание на \termdef{назначение адресов}{назначение адресов}\ для меток
\var{start}\ и \var{stop}: адреса начанаются с 0x0. Это адрес первой инструкции.
Метка \var{stop}\ находится после третьей инструкции. Каждая инструкция занимает
4 байта\note{в множестве команд ARM-32, если вы компилируете код для
микроконтроллера \cm x в режиме команд Thumb или Thumb2, команды 16-битные, т.е.
2 байта}, так что \var{stop}\ находится по адресу 0x$C_{hex}=12_{dec}$.
\termdef{Линковка}{линковка}\ с другим \termdef{базовым адресом}{базовый
адрес}\ \verb|-Ttext=nnnn|\ приведет к сдвигу адресов, назначенных меткам.

\bigskip
Выходной файл, созданный \prog{ld}\ имеет формат, который называется
\termdef{ELF}{ELF}. Существует множество форматов, предназначенных для хранения
выполняемого и объектного кода\note{можно отдельно отметить Microsoft COFF
(объектные файлы .obj) и PE (.exe)cutable}. Формат ELF применяется для хранения
машинного кода, если вы запускаете его в базовой ОС\note{прежде всего
``большой''\ или встраиваемый \linux}, но поскольку мы собираемся запускать нашу
программу на bare metal\note{голом железе}, мы должны сконвертировать полученный
.elf файл в более простой \termdef{бинарный формат}{бинарный формат}.

Файл в \term{бинарном формате}\ содержит последовательность байт, начинающуюся с
определенного адреса памяти, иногда его называют \term{образом памяти}. Этот
формат типичен для утилит программирования флеш-памяти микроконтроллеров, так
как все что требуется сделать\ --- последовательно скопировать каждый байт из
файла в FlashROM-память микроконтроллера, начиная с определенного начального
адреса в памяти.\note{Та же операция выполняется и для SoC-систем с NAND-флешем:
записать бинарный образ начиная с некоторого аппаратно фиксированного адреса.}

Команда \gnut\ \prog{objcopy}\ используется для конвертирования машинного кода
между разными объектными форматами. Типичное использование:

\begin{verbatim}
$ objcopy -O <выходной_формат> <входной_файл> <выходной_файл>
\end{verbatim}

Конвертируем \file{add.elf}\ в бинарный формат:

\begin{verbatim}
$ objcopy -O binary add.elf add.bin
\end{verbatim}

Проверим размер полученного бинарного файла, он должен быть равен тем же 16
байтам\note{4 инструкции по 4 байта каждая}:

\begin{verbatim}
$ ls -al add.bin
-rw-r--r-- 1 vijaykumar vijaykumar 16 2008-10-03 23:56 add.bin
\end{verbatim}

Если вы не доверяете \prog{ls}, можно дизассемблировать бинарный файл:

\begin{verbatim}
ponyatov@bs:/tmp$ arm-none-eabi-objdump -b binary -m arm -D add.bin

add.bin:     file format binary

Disassembly of section .data:

00000000 <.data>:
   0:   e3a00005        mov     r0, #5
   4:   e3a01004        mov     r1, #4
   8:   e0812000        add     r2, r1, r0
   c:   eafffffe        b       0xc
ponyatov@bs:/tmp$ 
\end{verbatim}
Опция \verb|-b|\ задает формат файла, опция \verb|-m|\ (machine) архитектуру
процессора, получить полный список сочетаний \verb|-b/-m|\ можно командной
\verb|arm-none-eabi-objdump -i|.

\secrel{Выполнение в \qemu}

Когда ARM-процессор сбрасывается, он начинает выполнять команды с адрсе 0x0.
На плате Commnex установлен флеш на 16 мегабайт, начинающийся с адрес 0x0. Таким
образом, при сбросе будут выполняться инструкции с начала флеша.

Когда \qemu\ эмулирует плату connex, в командной строке должен быть указан файл,
который будет считаться образом флеш-памяти. Формат флеша очень прост\ --- это
побайтный образ флеша без каких-либо полей или заголовков, т.е. это тот же самый
\term{бинарный формат}, описанный выше.

Для тестирования программы в эмуляторе Gumstix connex, сначала мы создаем
16-мегабайтный файл флеша, копируя 16М нулей из файла \file{/dev/zero}\ с
помощью команды \prog{dd}. Данные копируются 4Кбайтными блоками\note{опция bs=
(blocksize)} (4096 х 4К):

\begin{verbatim}
$ dd if=/dev/zero of=flash.bin bs=4K count=4K
4096+0 записей получено
4096+0 записей отправлено
 скопировано 16777216 байт (17 MB), 0,0153502 c, 1,1 GB/c

$ du -h flash.bin 
16M     flash.bin
\end{verbatim}

Затем переписываем начало \file{flash.bin}\ копируя в него содержимое
\file{add.bin}:

\begin{verbatim}
$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
0+1 записей получено
0+1 записей отправлено
 скопировано 16 байт (16 B), 0,000173038 c, 92,5 kB/c
\end{verbatim}

После сброса процессор выполняет код с адреса 0x0, и будут выполняться
инструкции нашей программы. Команда запуска \qemu:

\begin{verbatim}
$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null

QEMU 2.1.2 monitor - type 'help' for more information
(qemu) 
\end{verbatim}

Опция \verb|-M connex|\ выбирает режим эмуляции: \qemu\ поддерживает эмуляцию
нескольких десятков железа на базе ARM процессоров. Опция \verb|-pflash|\
указывает файл образа флеша, который должен иметь определенный размер (16М).
\verb|-nographic|\ отключает эмуляцию графического дисплея (в отдельном окне).
Самая важная опция \verb|-serial /dev/null|\ подключает последовательный порт
платы на \file{/dev/null}, при этом в терминале после запуска \qemu\ вы получите
\emph{консоль монитора}.

\qemu\ выполняет инструкции, и останавливается в бесконечном цикле на
\var{stop}, выполняя команду \verb|stop: b stop|. Для просмотра содержимого
регистров процессора воспользуемся \termdef{монитором}{монитор \qemu}.
Монитор имеет интерфейс командной строки, который вы можете использовать для
контроля работы эмулируемой системы. Если вы запустите \qemu\ как указано выше,
монитор будет доступен через stdio.

Для просмотра регистров выполним команду \verb|info registers|:

\begin{verbatim}
(qemu) info registers
R00=00000005 R01=00000004 R02=00000009 R03=00000000
R04=00000000 R05=00000000 R06=00000000 R07=00000000
R08=00000000 R09=00000000 R10=00000000 R11=00000000
R12=00000000 R13=00000000 R14=00000000 R15=0000000c
PSR=400001d3 -Z-- A svc32
FPSCR: 00000000
\end{verbatim}

Обратите внимание на значения в регистрах r00..r02: 4, 5 и ожидаемый результат
9. Особое значение для ARM имеет регистр r15: он является указателем команд, и
содержит адрес текущей выполняемой машинной команды, т.е. \verb|0x000c: b stop|.

\secrel{Другие команды монитора}

Несколько полезных команд:

\begin{tabular}{l l}
help & список доступных команд \\
quit & выход из эмулятора \\
xp /fmt addr & вывод содержимого физической памяти с адреса addr \\
system\_reset & перезапуск \\
\end{tabular}
\bigskip

Команда \verb|xp|\ требует некоторых пояснений. Аргумент \verb|/fmt|\ указывает
как будет выводиться содержимое памяти, и имеет синтаксис
\verb|<счетчик><формат><размер>|:

\begin{description}
\item[счетчик] число элементов данных
\item[size] размер одного элемента в битах: b=8 бит, h=16, w=32, g=64
\item[format] определяет формат вывода:
\begin{description}
\item[x] hex
\item[d] десятичные целые со знаком
\item[u] десятичные без знака
\item[o] 8ричные
\item[c] символ (char)
\item[i] инструкции ассемблера
\end{description}
\end{description}

Команда \verb|xp|\ в формате \verb|i|\ будет дизассемблировать инструкции из
памяти. Выведем дамп с адреса 0x0 указав fmt=4iw: 4\ --- 4 , i\ ---
инструкции размером w=32 бита:

\begin{verbatim}
(qemu) xp /4wi 0x0
0x00000000:  e3a00005      mov  r0, #5  ; 0x5
0x00000004:  e3a01004      mov  r1, #4  ; 0x4
0x00000008:  e0812000      add  r2, r1, r0
0x0000000c:  eafffffe      b    0xc
\end{verbatim}

\secup
\secrel{Директивы ассемблера}\secdown

В этом разделе мы посмотрим несколько часто используемых директив ассемблера,
используя в качестве примера пару простых программ.

\secrel{Суммирование массива}

Следующий код вычисляет сумму массива байт и сохраняет результат в \var{r3}:

\lstv{Листинг 2: Сумма массива}{kumar/arrsum.s}

\secrel{4.2. String Length}
\secup
\secrel{5. Using RAM}
\secrel{6. Linker}\secdown
\secrel{6.1. Symbol Resolution}
\secrel{6.2. Relocation}
\secup
\secrel{7. Linker Script File}\secdown
\secrel{7.1. Linker Script Example}
\secup
\secrel{8. Data in RAM, Example}\secdown
\secrel{8.1. RAM is Volatile!}
\secrel{8.2. Specifying Load Address}
\secrel{8.3. Copying .data to RAM}
\secup
\secrel{9. Exception Handling}
\secrel{10. C Startup}\secdown
\secrel{10.1. Stack}
\secrel{10.2. Global Variables}
\secrel{10.3. Read-only Data}
\secrel{10.4. Startup Code}
\secup
\secrel{11. Using the C Library}
\secrel{12. Inline Assembly}
\secrel{13. Contributing}
\secrel{14. Credits}\secdown
\secrel{14.1. People}
\secrel{14.2. Tools}
\secup
\secrel{15. Tutorial Copyright}
\secrel{A. ARM Programmer’s Model}
\secrel{B. ARM Instruction Set}\label{kumarB}
\secrel{C. ARM Stacks}
 
\secup 