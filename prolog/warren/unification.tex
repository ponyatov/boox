\secrel{2 Унификация\ --- ясно и просто 9}\label{warren2}\secdown

Напомним что терм (первого порядка)\ ---
\termdef{переменная}{\prolog!переменная} (задается большой буквой в начале
имени), \termdef{константа}{\prolog!константа} (задается маленькой буквой в
начале имени) или \termdef{терм}{\prolog!терм}\ --- структура вида
$f(t_1,\ldots,t_n)$, где $f$ символ называемый
\termdef{функтором}{\prolog|функтор} (записывается аналогично константе, с
маленькой буквы), а элементы $t_i$ тоже термы первого порядка\ ---
\termdef{субтермы}{\prolog!субтерм}. Число субтермов для данного функтора
предопределено, и называется \termdef{\'{а}рностью}{\prolog!арность} функтора.
Для обеспечения возможности использовать один и тот же символ с разной арностью,
мы должны использовать запись $f/n$, что обозначает функтор $f$ с арностью $n$.
Таким образом, два функтора равны только в том случае, если они имеют
\emph{одинаковые символ $f$ и арность $n$}. Разрешая случай $n=0$ можно
рассматривать константу как особый случай терма: константе $c$ соответствует
функтор $c/0$ с нулевой арностью.

We consider here $\mathcal L_0$, a very simple language indeed. In this
language, one can specify only two sorts of entities: a \termdef{program
term}{program term} and a \termdef{query term}{query term}.
Both program and query are first-order terms but not variables. The semantics of
$\mathcal L_0$ is simply tantamount to computing the most general unifier of the
program and the query. As for syntax, $\mathcal L_0$ will denote a program as
\verb|t| and a query as \verb$?-t$ where \verb$t$ is a term. The scope of
variables is limited to a program (resp., a query) term. Thus, the meaning of a
program (resp., a query) is independent of its variables’ names. An interpreter
for $\mathcal L_0$ will dispose of some data representation for terms and use a
unification algorithm for its operational semantics. We next describe $\mathcal
M_0 = (\mathcal D_0,\mathcal I_0)$ , an abstract machine design for $\mathcal
L_0$ consisting of a data representation $\mathcal D_0$ acted upon by a set
$\mathcal I_0$ of machine instructions.

The idea is quite simple: having defined a program term $p$, one can submit any
query \verb|?-q| and execution either fails if $p$ and $q$ do not unify, or
succeeds with a binding of the variables in $q$ obtained by unifying it with
$p$.

\secrel{2.1 Term representation . . . . . . . . . . . . . . . . . . . . . . . .
. 10 }

\secrel{2.2 Compiling L
queries . . . . . . . . . . . . . . . . . . . . . . . . 11}

\secrel{2.3 Compiling L
programs . . . . . . . . . . . . . . . . . . . . . . . 13}

\secrel{2.4 Argument registers . . . . . . . . . . . . . . . . . . . . . . . . .
19}

\secup
