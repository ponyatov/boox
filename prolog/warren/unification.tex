\secrel{2 Унификация\ --- ясно и просто 9}\label{warren2}\secdown

Recall that a (first-order) term is either a \termdef{variable}{variable}\
(denoted by a capitalized identifier), a \termdef{constant}{constant} (denoted
by an identifier starting with a lower-case letter) or a
\termdef{structure}{structure} of the form $f(t_1,\ldots,t_n)$ where $f$ is a
symbol called a \termdef{functor}{fucntor} (denoted as a constant), and the
$t_i$’s are first-order terms\ --- the term’s \termdef{subterms}{subterm}. The
number of subterms for a given functor symbol is predetermined and called its
\termdef{arity}{functor arity}. In order to allow a symbol to be used with
possibly different arities, we shall use the explicit notation $f/n$ when
referring to the functor consisting of the symbol $f$ and arity $n$. Hence, two
functors are equal if and only if they have the same symbol \emph{and} arity.
Letting $n=0$, a constant is seen as a special case of a structure. Thus, a
constant $c$ will be designated as the functor $c/0$.

We consider here $\mathcal L_0$, a very simple language indeed. In this
language, one can specify only two sorts of entities: a \termdef{program
term}{program term} and a \termdef{query term}{query term}.
Both program and query are first-order terms but not variables. The semantics of
$\mathcal L_0$ is simply tantamount to computing the most general unifier of the
program and the query. As for syntax, $\mathcal L_0$ will denote a program as
\verb|t| and a query as \verb$?-t$ where \verb$t$ is a term. The scope of
variables is limited to a program (resp., a query) term. Thus, the meaning of a
program (resp., a query) is independent of its variables’ names. An interpreter
for $\mathcal L_0$ will dispose of some data representation for terms and use a
unification algorithm for its operational semantics. We next describe $\mathcal
M_0 = (\mathcal D_0,\mathcal I_0)$ , an abstract machine design for $\mathcal
L_0$ consisting of a data representation $\mathcal D_0$ acted upon by a set
$\mathcal I_0$ of machine instructions.

The idea is quite simple: having defined a program term $p$, one can submit any
query \verb|?-q| and execution either fails if $p$ and $q$ do not unify, or
succeeds with a binding of the variables in $q$ obtained by unifying it with
$p$.

\secrel{2.1 Term representation . . . . . . . . . . . . . . . . . . . . . . . .
. 10 }

\secrel{2.2 Compiling L
queries . . . . . . . . . . . . . . . . . . . . . . . . 11}

\secrel{2.3 Compiling L
programs . . . . . . . . . . . . . . . . . . . . . . . 13}

\secrel{2.4 Argument registers . . . . . . . . . . . . . . . . . . . . . . . . .
19}

\secup
