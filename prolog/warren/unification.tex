\secrel{Унификация\ --- ясно и просто}\label{warren2}\secdown

Напомним что терм (первого порядка)\ ---
\termdef{переменная}{\prolog!переменная} (задается большой буквой в начале
имени), \termdef{константа}{\prolog!константа} (задается маленькой буквой в
начале имени) или \termdef{терм}{\prolog!терм}\ --- структура вида
$f(t_1,\ldots,t_n)$, где $f$ символ называемый
\termdef{функтором}{\prolog|функтор} (записывается аналогично константе, с
маленькой буквы), а элементы $t_i$ тоже термы первого порядка\ ---
\termdef{субтермы}{\prolog!субтерм}. Число субтермов для данного функтора
предопределено, и называется \termdef{\'{а}рностью}{\prolog!арность} функтора.
Для обеспечения возможности использовать один и тот же символ с разной арностью,
мы должны использовать запись $f/n$, что обозначает функтор $f$ с арностью $n$.
Таким образом, два функтора равны только в том случае, если они имеют
\emph{одинаковые символ $f$ и арность $n$}. Разрешая случай $n=0$ можно
рассматривать константу как особый случай терма: константе $c$ соответствует
функтор $c/0$ с нулевой арностью.

Мы рассмотрим очень простой низкоуровневый\note{IL\--- Intermediate Language}\
язык $\mathcal L_0$. На этом языке мы можем описать два вида объектов:
\termdef{терм программы}{\prolog!терм программы} и \termdef{терм
запроса}{\prolog!терм запроса}. Оба этих вида запросов являются термами первого
порядка, но не переменными. Семантика $\mathcal L_0$ равносильна вычислению
самого общего унификатора программы или запроса. Что касается синтаксиса,
$\mathcal L_0$ будет описывать программу как \verb|t| и запрос как \verb$?-t$
где \verb$t$ является термом. Область видимости переменных ограничена термом
программы/запроса. Таким образом, \emph{значение программы не зависит от имен ее
переменных}. Интерпретатор для $\mathcal L_0$ будет использовать определенное
представление данных для термов и использовать алгоритм унификации для ее
операционной семантики. Затем мы опишем $\mathcal M_0 = (\mathcal D_0,\mathcal
I_0)$ , дизайн абстрактной машины для $\mathcal L_0$ содержащий представление
данных $\mathcal D_0$, над которыми выполняется множество $\mathcal I_0$
машинных инструкций.

Идея достаточно проста: имея определенных программный терм $p$, мы можем
выполнить лююбой запрос \verb|?-q|, и выполнение запроса завершится с ошибкой
если $p$ и $q$ не унифицируются, или будет успешным с привязкой переменных
в $q$ полученной при унификации запроса с $p$.

\input{prolog/warren/termrepr}

\secrel{2.2 Compiling L
queries . . . . . . . . . . . . . . . . . . . . . . . . 11}

\secrel{2.3 Compiling L
programs . . . . . . . . . . . . . . . . . . . . . . . 13}

\secrel{2.4 Argument registers . . . . . . . . . . . . . . . . . . . . . . . . .
19}

\secup
