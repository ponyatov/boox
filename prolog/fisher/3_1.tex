\secrel{Деривационные деревья, выборы и унификация}\label{fish31}

Для иллюстрации того, как \prolog-программа создает ответы, рассмотрим следующую
простую программу регистрации данных (это не функции):

\lst{}{prolog/fisher/3_1.pl}{Prolog}

\paragraph{Упражнение \ref{fish31}.1} Загрузите программу \prog{P}\ в \prolog\ и
посмотрите что случится при вводе цели \verb|?-p(X)|. Когда будет выведен ответ,
нажимайте \keys{;} чтобы \prolog\ продолжил трассировку и нашел все ответы.

\paragraph{Упражнение \ref{fish31}.2} Загрузите программы, включите
трассировку, и посмотрите что происходит при вводе той же цели.
Нажимайте \keys{Enter} в каждой строке трассировки, и \keys{;} в
конце строки ответа, чтобы найти все остветы. Используйте \verb|?-help(trace)|
если необходимо.

\lstv{Трассировка}{prolog/fisher/3_1.trace}

Следующая диаграмма показывает полное \termdef{дерево вывода}{дерево вывода} для
цели \verb|?-p(X)|. Ребра помечены номером утверждения в исходномо файле
программы \prog{P}, которое было использовано для подмены цели подцелями.
Прямые потомки под каждой (под)целью в дереве вывода соответствуют
\term{вариантам выбора}. Например корневая цель \verb|p(X)|
\termdef{унифицируется}{унификация} заголовками утверждений \#1, \#2, \#3,
порождая три выбора.

\fig{}{prolog/fisher/f3_1_1.png}{width=0.9\textwidth}

Трассировка упражнения \ref{fish31}.2 для цели \verb|?-p(X)| соответствует
обходу дерева вывода вглубь. Каждый узел дерева вывода \prolog а в определенный
момент времени становится текущей целью. Аналогично каждый узел\ ---
последовательность субцелей. Ребра сразу ниже узла соотвутсвуют доступным
выборам замены для текущего узла. Текущий side clause, номер которого отмечает
дугу в дереве вывода, тестируется следующим способом: если самая левая подцель
текущего узла\note{отмечена как \var{g1} в небольшой диаграмме ниже}
унифицируется головой side clause\note{отмечена как \var{h} в диаграмме}, затем
самая левая подцель заменяется телом side clause\note{ \var{b1,b2,...,bn}}.
Графически мы можем это показать вот так:

\fig{}{prolog/fisher/f3_1_2.png}{width=0.5\textwidth}

Одна важная вещь не показана в диаграмме\ --- логические переменные в
результирующей цели \verb|b1,b2,...,bn,g2,g3,...| были привязаны в результате
унификации, и \prolog\ требует отслеживать эти унифицирующие подстановки, в
процессе роста дерева вывода вниз, во всех ветках.

Итак, обход дерева вывода вглубь значат что альтернативные варианты выбора будут
проверены тогда, когда поиск возвратиться в точку ветвления, содержащую этот
выбор. Процесс называется \termdef{backtracking}{backtracking}.

Естественно, если хвост цели пуст, самая левая подцель 
эффективно удаляется. Если все подцели могут быть удалены по одному из путей
дерева вывода, то находится ответ, и возвраается резщультат \verb|true|. В этой
точке привязки переменных могут быть использованы для дачи ответа на
оригинальный запрос.

