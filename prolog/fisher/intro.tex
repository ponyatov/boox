\secly{Введение}

\prolog\ --- язык декларативного логического программирования. Детально
рассматривая его имя, получаем что это сокращение от \textsc{pro}gramming in
\textsc{log}ic: логическое программирование. Наследие \prolog а включает
исследования в области \term{автоматического доказательства теорем} и других
\term{дедуктивных систем}, разработанных в 1960-70хх гг. \term{Механизм вывода}
\prolog а базируется на принципе разрешения Робинсона (1965) и механизмах вывода
ответов, приложенных Грином (1968). Эти идеи используются вместе с продедурами
линейного разрешения. Процедуры точного целевого линейное разрешения, такие как
методы Kowalski / Kuehner (1971) и Kowalski (1974), дали толчок к разработке
систем логического программирования общего назначения. ``Первым'' \prolog ом был
``Марсельский \prolog'', реализация которого основана на работе Colmerauer
(1970). Первым делательным описанием языка \prolog\ было руководство к
интерпретатору Marseille Prolog (Roussel, 1975). Другим сильным влиянием на
природу этого первого \prolog а была адаптация этого интерпретатора к задачам
\term{обработки натуральных языков}.

\prolog\ является наиболее часто упоминаемым примеров языков программирования
четвертого поколения, которые поддерживают парадигму \emph{декларативного
программирования}. Японский проект Fifth-Generation Computer
Project\note{компьютерный проект пятого поколения}, анонсированный в 1981,
применял \prolog\ как язык разработки, и сосредоватчивал значительные усилия на
языке и его возможностях. Программы в этом учебнике написаны на ``стандартном''
\prolog е Эдинбургского университета\note{University of Edinburgh Prolog}, как
это сделано к классической книге по \prolog у под авторством Clocksin и Mellish
(1981,1992). Другой заметной версией \prolog а является семейство реализаций
\prolog II, которые являются ответсвлениями Марсельского \prologа. Справочник
Giannesini, et.al. (1986) использует версию \prolog II. Есть некоторые различия
бежду этими двумя вариантами \prolog а; часть различий в синтаксисе, и часть в
семантике. Тем не менее, студенты изучавшие одну из версий, впоследствии могут
легко адаптировать к другой.

Цель этого учебника\ --- помочь изучить самые необходимые, базовые концепции
языка \prolog. Примеры программ были особенно аккуратно выбраны для иллюстрации
программирования искуственного интлеллекта на \prolog е. \lisp\ и \prolog\
наиболее часто используемые языки символьного программирования для приложений
искуственного интеллекта. Они часто упоминаются как великолепные языки для
``исследовательского'' и ``прототипного программирования''.

Раздел \ref{fish1} рассматривает среду программирования на \prolog е для
начинающих.

Раздел \ref{fish2} объясняет синтаксис \prolog а и многие аспекты
программирования на нем через реализацию аккуратно выборанных программ-примеров.
Эти примеры организованы так, чтобы студент обучался через реализацию
\prolog-программ ``сверху вниз'' в декларативном стиле.
Были приняты меры к рассмотрению техник программирования на \prolog е, которые
очень важны для курса искуственного интеллекта. Фактически, \emph{этот учебник
может служить удобным, маленьким, кратким введением в применение \prolog а в
приложениях искуственного интеллекта}. Аспекты семантики языка \prolog\
рассмотриваются с самого начала с точки зрения концепции дерева условий
программы, которое используется для определения последовательностей спецификаций
\prolog-программы в абстрактном виде. Автор надеется что этот подход позволит
рассмотреть базовые принципы формальной верификации программ при
программировании на \prolog е. Последняя секция этого раздела приводит пример,
который показывает что \prolog\ может быть эффективно использован для
аккуратной, точной спецификации программных систем, несмотря на его репутацию
трудно документируемого языка, так что \prolog\ легко использовать как средство
прототипирования.

Раздел \ref{fish3}\ рассматривает работу внутренних механизмов \prolog-движка.
Раздел \ref{fish3}\ рекомендуется просмотреть сразу после того, как студент
изучил 2-3 примера программ из раздела \ref{fish2}. Последняя секция этого
радела рассматривает \term{мета-интерпретаторы \prolog а}.

Раздел \ref{fish4}\ дает краткий обзор основных встроенных предикатов, многие из
которых используются в разделе \ref{fish2}..

Раздел \ref{fish5}\ рассматривает разработку программ A*-поиска на \prolog е.
Раздел \ref{fish53}\ содержит программу $\alpha\beta$-поиска для игры 
tic tac toe.

Раздел \ref{fish6}\ представляет уникальное и обширное описание логического
мета-интерпретатора для нормальных логических баз правил.\note{Замечание от
9/4/2006: Я значительно отредактировал этот раздел, и обновил все ссылки на
секции.}

Раздел \ref{fish7}\ предствляет введение во встроенный в \prolog\ генератор
парсеров грамматики, и дает общий обзор приемов, с помощью которых \prolog\
может быть использован для разбора выражений натурального языка (английского).
Также эта секция описывает построение программных интерфейсов, использующих
идеоматически-простые натуральные языки.

Раздел \ref{fish8}\ показывает приемы реализации различных \prolog-прототипов.
Новый раздел \ref{fish84}\ раскрывает интерактивную связку между машиной вывода
\prolog а и Java GUI для игры tic tac toe. Рассмотренная простая модель связки
легко адаптируемая и применима.

Ранние версии частей этого учебника датируются 1988 годом. Вводный материал
изначально использовался для объяснения работы интерпретатора \prolog а,
разработанного автором\note{сейчас недоступен}\ для применения в учебном
процессе. Автор надеется что вводный материал, собранный в форме этого учебника,
может быть очень полезным для студентов, которые хотят быстрое, но при этом
хорошо сбалансированное, введение в программирование на \prolog е.

Для дальнейшего изучения \prolog а можно посоветовать книги
Clocksin и Mellish (1981,1992), O'Keefe (1990), Clocksin (1997, 2003),
или Sterling и Shapiro (1986).

Подробные заметки по истории \prolog\ и обработке натуральных языков с его
использованием содержатся в работе Pereira and Shieber (1987).

\copyright\ Помона, Калифорния\\ 1988-2015
