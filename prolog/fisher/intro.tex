\secly{Введение}

\prolog\ --- язык декларативного логического программирования. Детально
рассматривая его имя, получаем что это сокращение от \emph{pro}gramming in
\emph{log}ic: логическое программирование.

The name itself, \prolog, is short for PROgramming in LOGic. Prolog's heritage includes the
research on theorem provers and other automated deduction systems developed in
the 1960s and 1970s. The inference mechanism of Prolog is based upon Robinson's
resolution principle (1965) together with mechanisms for extracting answers
proposed by Green (1968). These ideas came together forcefully with the advent
of linear resolution procedures. Explicit goal-directed linear resolution
procedures, such as those of Kowalski and Kuehner (1971) and Kowalski (1974),
gave impetus to the development of a general purpose logic programming system.
The "first" Prolog was "Marseille Prolog" based on work by Colmerauer (1970).
The first detailed description of the Prolog language was the manual for the
Marseille Prolog interpreter (Roussel, 1975). The other major influence on the
nature of this first Prolog was that it was designed to facilitate natural
language processing.

Prolog is the major example of a fourth generation programming language
supporting the declarative programming paradigm. The Japanese Fifth-Generation
Computer Project, announced in 1981, adopted Prolog as a development language,
and thereby focused considerable attention on the language and its capabilities.
The programs in this tutorial are written in "standard" (University of)
Edinburgh Prolog, as specified in the classic Prolog textbook by authors
Clocksin and Mellish (1981,1992). The other major kind of Prolog is the PrologII
family of Prologs which are the descendants of Marseille Prolog. The reference
to Giannesini, et.al. (1986) uses a version of PrologII. There are differences
between these two varieties of Prolog; part of the difference is syntax, and
part is semantics. However, students who learn either kind of Prolog can easily
adapt to the other kind.

This tutorial is intended to be used to help learn the essential, basic concepts
of Prolog. The sample programs have been especially chosen to help promote the
use of Prolog programming in an artificial intelligence course. Lisp and Prolog
are the most frequently used symbolic programming languages for artificial
intelligence. They are widely regarded as excellent languages for "exploratory"
and "prototype programming".

Chapter 1 explains the Prolog programming environment for the beginner.

Chapter 2 explains Prolog syntax and many essentials of Prolog programming
through the use of carefully chosen sample programs. The sample programs are
arranged to guide the student through the development of Prolog programs that
are constructed in a top-down, declarative fashion. Care has been taken to cover
Prolog programming techniques that are very useful in an artificial intelligence
course. In fact, this primer can serve as a convenient, small, concise Prolog
introduction for such a course. Semantic issues have been addressed by
introducing early the concept of a program clause tree that is used to define in
an abstract way what are supposed to be the consequences of a Prolog program
specification. The author believes this to be a viable way to promote the basic
semantic issues of software verification for Prolog programming. The last
section of this chapter introduces an example that shows that Prolog can be
effectively used to give careful, precise specifications of systems, contrary to
its usual reputation as being hard to document because it is easy to use as an
exploratory programming tool.

Chapter 3 explains the operation of the underlying inference engine of Prolog.
Chapter 3 should be first read after the student has studied two or three of the
sample programs in Chapter 2. The last section in this chapter introduces Prolog
meta-interpreters.

Chapter 4 gives an outlined view of the major built-in predicates of Prolog,
many of which are exemplified in Chapter 2.

Chapter 5 gives an outline for developing A* search programs in prolog.  Section
5.3 has an $\alpha\beta$ search program for the game of tic tac toe.

Chapter 6 presents a unique and extensive presentation of a logic
meta-interpreter for normal logical rulebases.\note{Note 9/4/2006: I have
edited this chapter heavily, and the section links are all new.}

Chapter 7 gives an introduction to Prolog's built-in grammar parser generator,
and a brief overview of how Prolog can be used to parse English (natural
language) sentences. Also, there is a section covering the construction of
simple idiomatic natural language interfaces to programs.

Chapter 8 shows how to implement varios prolog prototypes. A new section (§8.4)
develops an interactive connection between prolog (inference engine) and Java
(GUI) to play tic tac toe. The simple connection model is quite widely adaptable
and applicable.

Earlier versions of portions of this tutorial date back to 1988. The
introductory material was originally used to help explain a Prolog interpreter
developed by the author (no longer available) for use in his courses. The author
believes that the introductory material, gathered together in the form given
here might be very useful for the student who wants a quick, but well-tailored,
introduction to Prolog.

For fuller treatments of Prolog the student is advised to see the textbooks by
Clocksin and Mellish (1981,1992), by O'Keefe (1990), by Clocksin (1997, 2003),
or by Sterling and Shapiro (1986).

For excellent historical notes regarding Prolog and natural language processing
using Prolog the text by Pereira and Shieber (1987) is recommended.

\copyright\ Pomona, California\\ 1988-2015
