\secrel{Два определения факториала}\label{fish22}

Этот раздел вводит в вычисления математических функций используя \prolog.
Обсуждаются различные встроенные арифметические операции. Также обсуждается
концепция derivation дерева, и как derivation деревья связаны с трассировкой в
\prolog е.

В файле \file{2\_2.pl} находятся два определения предикатов, являющиеся
определением фукнции вычисления факториала:

\lst{первый вариант}{prolog/fisher/2_2.pl}{Prolog}
 
Эта программа состоит из двух clauses. Первое заключение\ --- формулировка
\termdef{факта}{факт} (unit clause) \emph{без тела}. Второе заключение\ ---
\termdef{правило}{правило}, так как \emph{у него есть тело}. Тело второго
заключения находится после \verb|:-|, которое можно читать как ``если''. Тело
содержит литералы, разделенные запятыми, каждую запятую можно читать как ``и``.
\termdef{Заголовок правила}{заголовок правила}\ --- весь текст \term{факта} или
часть текста до \verb|:-| в правиле. Рассматривая текст как декларативную
программу, первое (фактическое) предложение читается как ``факториал 0 есть
1''\note{или: 0 и 1 \term{связаны отношением} ``факториал'', но у объектов
одновременно могут быть и другие отношения, например биты(0,1) и целые(0,1)},
и второе предложение заявляет что ``факториал \var{N} есть \var{F}\note{точнее:
N и F связаны отношением ``факториал''} если \verb|N>0| и \var{N1} есть
\verb|N-1| , и факториал \var{N1} есть \var{F1}, и \var{F} есть \verb|N*F1|.

\termdef{\prolog-цель}{цель (Пролог)} (goal) для вычисления факториала от 3
дает ответ в W\ --- \termdef{переменной цели}{переменная цели}:

\begin{verbatim}
?-  factorial(3,W).  
W=6 . 
\end{verbatim}

Рассмотрим следующее clause дерево сконструированное для литерала\\
\verb|factorial(3,W)|. Как описано в предыдущей секции, clause дерево не
содержит никаких свободных переменных, вместо этого включает непосредственно их
значения. Каждое ветвление под узлом определяется clause оригинальной программы,
используя непосредственно вхождения значений переменных; узел задается
заголовком правила, а литералы теля становятся дочерними узлами.

\fig{}{prolog/fisher/f2_2.pdf}{width=0.95\textwidth}

\emph{Все арифметические листья \var|true|} при исполнении\note{в соответствие с
предполагаемой интерпретацией}, и самая нижная связь в дереве соответствует
самому первому clause в программе вычисленяи факториала. Первый clause может
быть записан как:

\begin{verbatim}
factorial(0,1) :- true. 
\end{verbatim}
и фактически \verb|?- true.| \prolog-цель которая всегда успешна
\note{\var{true} встроеннный предикат}. Для краткости, мы не отрисовали
\verb|true| для всех листьев, являющихся арифметическими литералами.

Программное clause дерево показывает значение цели в коорне дерева. Так,\\
\verb'factorial(3,6)' является консеквенцией \prolog-программы, так как
существует clause дерево с корнем \verb'factorial(3,6)', все листья которого
\verb|true|. С другой стороны литерал \verb'factorial(5,2)' не консеквенция,
так как такого дерева для него нет, а значением программы для литерала
\verb'factorial(5,2)' является \verb|false|:

\begin{verbatim}
?- factorial(3,6).  
true .
?- factorial(5,2).  
false . 
\end{verbatim}
как и следовало ожидать. Clause-деревья также называются AND-деревьями, так как
чтобы корень был консеквенцией программы, все его поддеревья также должны быть
консеквенциями. Позже clause деревья будут рассмотрены подробнее. Мы отметили
что \emph{clause дерево описывает семантику (значение) программы}. В разделе
\ref{fish6} мы рассмотрим другой подход к семантике программ. Clause-деревья
предоставляют интуитивный и корректный подход к описанию семантики.

\bigskip

Нам нужно отличать clause деревья программы и \termdef{деревья
вывода}{дерево вывода}. Сlause-деревья статичны, и могут быть нарисованы для
программмы или цели через механизм удовлетворения частичных (под)целей, как
описано выше. Грубо говоря, clause-деревья соответствуют декларативному чтению
программы.

\term{Деревья вывода} наоборот, имеют в виду механизм привязки переменных
\prolog а, и порядок в котором удовлетворяются вложенные частичные цели.
Подробнее деревья вывода описаны в разделе \ref{fish31}, но тем не менее
посмотрите анимацию, предоставляемую динамическим отладчиком, как описано ниже.

\termdef{Трассировка}{трассировка} исполнения \prolog-программы также показывает
как переменные привязываются при удовлетвормении целей. Следующий пример
показывает включение/выключение трассировки в типичной \prolog-системе.

\begin{verbatim}
?- trace. 
% The debugger will first creep -- showing everything (trace). 
 
true .
[trace] 
?- factorial(3,X). 
  (1) 0 Call: factorial(3,_8140) ? [Enter] creep 
  (1) 1 Head [2]: factorial(3,_8140) ? [Enter] creep 
  (2) 1 Call (built-in): 3>0 ?  creep
  (2) 1 Done (built-in): 3>0 ?  creep
  (3) 1 Call (built-in): _8256 is 3-1 ? creep 
  (3) 1 Done (built-in): 2 is 3-1 ?  creep
  (4) 1 Call: factorial(2, _8270) ?  creep
   ... 
  (1) 0 Exit: factorial(3,6) ? 
X=6 .
[trace] 
?- notrace. 
% The debugger is switched off 
 
true .
\end{verbatim}

The animated tree below gives another look at the derivation tree for the
\prolog goal \verb'factorial(3,X)'. To start (or to restart) the animation,
simply click on the \keys{Step} button.

\bigskip

Заголовок этого раздела говорит ``\emph{Два} определения факториала'', вот
второй вариант, использующий три переменых:

\lst{второй вариант}{prolog/fisher/2_2_2.pl}{Prolog}

Для этой версии используйте следующую цель-запрос:

\begin{verbatim}
?- factorial(5,1,F). 
F=120 .
\end{verbatim}

Второй параметр в определении называется \term{параметр-аккумулятор}, который
также хорошо известен в функциональном программировании. Эта версия факториала
определена с использованием \term{хвостовой рекурсии}. Важно чтобы вы выполнили
следующие упражнения:

\paragraph{Упражнение 2.2.1} Используя первый вариант программы факториала,
четко покажите что не существует clause-дерева с корнем \verb'factorial(5,2)',
имеющего все true листья.

\paragraph{Упражнение 2.2.2} Нарисуйте clause-дерево для цели
\verb'factorial(3,1,6)' со всеми true-листьями, в виде аналогичном ранее
описанному дереву для \verb'factorial(3,6)'.
Покажите, чем отличаются два варианта программы в процессе вычисления
факториала\,? Также, протрассируйте цель \verb'factorial(3,1,6)' используя
\prolog-систему.
