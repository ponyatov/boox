\secrel{Два определения факториала}\label{fish22}

Этот раздел вводит в вычисления математических функций используя \prolog.
Обсуждаются различные встроенные арифметические операции. Также обсуждается
концепция derivation дерева, и как derivation деревья связаны с трассировкой в
\prolog е.

В файле \file{2\_2.pl} находятся два определения предикатов, являющиеся
определением фукнции вычисления факториала:

\lst{2.2}{prolog/fisher/2_2.pl}{Prolog}
 
Эта программа состоит из двух clauses. Первое заключение\ --- формулировка
\termdef{факта}{факт} (unit clause) \emph{без тела}. Второе заключение\ ---
\termdef{правило}{правило}, так как \emph{у него есть тело}. Тело второго
заключения находится после \verb|:-|, которое можно читать как ``если''. Тело
содержит литералы, разделенные запятыми, каждую запятую можно читать как ``и``.
\termdef{Заголовок правила}{заголовок правила}\ --- весь текст \term{факта} или
часть текста до \verb|:-| в правиле. Рассматривая текст как декларативную
программу, первое (фактическое) предложение читается как ``факториал 0 есть
1''\note{или: 0 и 1 \term{связаны отношением} ``факториал'', но у объектов
одновременно могут быть и другие отношения, например биты(0,1) и целые(0,1)},
и второе предложение заявляет что ``факториал \var{N} есть \var{F}\note{точнее:
N и F связаны отношением ``факториал''} если \verb|N>0| и \var{N1} есть
\verb|N-1| , и факториал \var{N1} есть \var{F1}, и \var{F} есть \verb|N*F1|.

\termdef{\prolog-цель}{цель (Пролог)} (goal) для вычисления факториала от 3
дает ответ в W\ --- \termdef{переменной цели}{переменная цели}:

\begin{verbatim}
?-  factorial(3,W).  
W=6 . 
\end{verbatim}

Рассмотрим следующее clause дерево сконструированное для литерала\\
\verb|factorial(3,W)|. Как описано в предыдущей секции, clause дерево не
содержит никаких свободных переменных, вместо этого включает непосредственно их
значения. Каждое ветвление под узлом определяется clause оригинальной программы,
используя непосредственно вхождения значений переменных; узел задается
заголовком правила, а литералы теля становятся дочерними узлами.

\fig{}{prolog/fisher/f2_2.pdf}{width=0.95\textwidth}

\emph{Все арифметические листья \var|true|} при исполнении\note{в соответствие с
предполагаемой интерпретацией}, и самая нижная связь в дереве соответствует
самому первому clause в программе вычисленяи факториала. Первый clause может
быть записан как:

\begin{verbatim}
factorial(0,1) :- true. 
\end{verbatim}
и фактически \verb|?- true.| \prolog-цель которая всегда успешна
\note{\var{true} встроеннный предикат}. Для краткости, мы не отрисовали
\verb|true| для всех листьев, являющихся арифметическими литералами.

Программное clause дерево показывает значение цели в коорне дерева. Так,\\
\verb'factorial(3,6)' является консеквенцией \prolog-программы, так как
существует clause дерево с корнем \verb'factorial(3,6)', все листья которого
\verb|true|. С другой стороны литерал \verb'factorial(5,2)' не консеквенция,
так как такого дерева для него нет, а значением программы для литерала
\verb'factorial(5,2)' является \verb|false|:

\begin{verbatim}
?- factorial(3,6).  
true .
?- factorial(5,2).  
false . 
\end{verbatim}
как и следовало ожидать. Clause-деревья также называются AND-деревьями, так как
чтобы корень был консеквенцией программы, все его поддеревья также должны быть
консеквенциями. Позже clause деревья будут рассмотрены подробнее. Мы отметили
что \emph{clause дерево описывает семантику (значение) программы}. В разделе
\ref{fish6} мы рассмотрим другой подход к семантике программ. Clause-деревья
предоставляют интуитивный и корректный подход к описанию семантики.

\bigskip

