\secrel{M-GRAMMARS AND DCGs }\label{cohen3}

A metamorphosis (or M-) grammar is a formalism which combines a Chomskytype
language definition with logic programming capabilities for manipulating
the semantic attributes needed to perform syntax-directed translations.
Colmerauer [9] maps general type-0 Chomsky rules into general logicprogramming
clauses, (i.e., those that may contain more than one predicate in
the left-hand side). A very useful subset of M-Grammars are Definite Clause
Grammars (DCGs), which are based on Chomsky’s context-free grammars. The
reader has undoubtedly noticed the similarity between Prolog clauses and context-free
grammar rules: they both have one term in the lhs and several (or none,
i.e., t) in the rhs. Prolog restricts itself to those special clauses called Horn or
Definite clauses, thus explaining the acronym. It will be seen shortly that
although DCGs are based on context-free grammars they are able to parse
context-sensitive ones as well. (In fact, any recursively enumerable language can
be recognized using DCGs with parameters.) 

DCGs are translated directly into Prolog clauses which include a recursive
descent parser using difference lists. For example, the DCG rules for recognizing
strings in G3 are
\[s --+ [cl.\]
\[s --+ [a], s, [b].\]
The syntax of DCGs is close to that of Prolog clauses. The ‘:-’ is replaced
by ‘--+‘, and terminals appear within square brackets. Most Prolog interpreters
automatically translate the above into the clauses:
\[s([c I m, LO).\]
\[s([a 1 LO], Ll) :- s(L0, [b I Ll]).\]
which have already been explained in Section 2.3. DCG terms usually contain
one or more arguments which are directly copied into their Prolog counterparts,
which also contain the difference list parameters. Our first example of usage of
DCGs is to determine the value of n for a given input string a”\&” (generated by
grammar GB ).
\[s(0) --+ [cl.\]
\[s(succW) --+ [al, SW), PI.\]
The added argument specifies that the recognition of a c implies a value of
N = 0. Each time an s surrounded by an a and a b is recognized, the value of N
increases by one (succ indicates the successor). The above DCGs are automatically
translated into
\[SK4 [c I w, LO).\]
\[s(succ(N), [a 1 LO], Ll) :- s(N, LO, [b I Ll]).\]
The call s(X, [a, a, c, b, b], [ ]) yields X = succ(succ(0)). The backtracking
capabilities of Prolog allow the call s(succ(succ(O)), X, [ ]) which yields X =
[a, a, c, b, b]. 

By employing a technique similar to the one illustrated by the previous
example, we can construct a parser s to recognize the language a”b”c”. It uses
the auxiliary procedure sequ.ence(X, N) (defined below) which parses a list of Xs
and binds N to the number of Xs found.
\[sequence(X, 0) --+ [ 1.\]
\[sequence(X, succ(N)) --+ [Xl, sequeme(X, IV)\]
\[s(N) --+ sequence(a, N), sequence(b, N), seqwme(c, IV)\]

Let us now consider the use of DCGs for translating arithmetic expressions
into their syntax-trees. We start with the simplified right-recursive grammar
rules:
\[E-T +E\]
\[E-T\]
\[T-a\]
Initially one would be tempted to use the DCG
\[eWw(X, Y)) --+ W3, [+I, e(y).\]
\[e(X) --+ t(X).\]
\[t(a) --9 [a].\]
These rules, however, translate a + a + a into plus (a, pZus(u, a)) which is rightassociative,
and therefore semantically incorrect. Some cunning is needed to 
circumvent this difficulty. Let us first rewrite the grammar rules as
\[E+TR\]
\[R++TR\]
\[R-,C\]
\[T+a\]
Our goal is to generate plus(plus(a, a), a) for the input string a + a + a. The
following DCG will do the proper translation:
\[eqv\$?3) --9 term(Tl), restexpr(T1, E).\]
\[restexpr(T1, E) --a [+I, term(T2), restezpr(plus(T1, T2), E).\]
\[restexpr(\&, E) --+ [ 1.\]
\[term(a) -3 [a].\]
When the clause expr recognizes the first term Tl in the expression, it passes
this term to the second clause, restexpr. If there is another term T2 following
Tl, then the composite term pb(T1, T2) is constructed and recursively passed
to restexpr. The first parameter of restexpr is used to build a left-recursive parse
tree, which is finally transmitted back to erpr by the third clause. 

Unfortunately, the above “contortions” are needed if one insists on using a
recursive descent parser to contruct a left-associative syntax tree. This particular
Prolog technique has become a standard idiom among DCG writers. A way out
of this predicament is to implement DCGs using bottom-up parsers. (This has
been proposed in [28].) At present these capabilities are not generally available
in existing Prolog interpreters and compilers. 

It is straightforward to generalize the above translation by introducing multilevel
grammar rules such as
\[Ei + TiRi\]
\[Ri + OpiTiRi\]
\[\& + \&+I\]
\[Ri + c\]
with 1 5 i 5 n and En+, + letter ] (El), where i denotes the precedence of the
operator opi. The corresponding DCG contains i as a parameter, and could allow
for redefining the priorities of the operators, therefore rendering the language
extensible. This approach is used in the Edinburgh version of Prolog.      

A very useful feature of DCGs is that parts of Prolog programs may appear in
their right-hand sides. This is done by surrounding the desired Prolog predicates
within curly brackets. Our next example illustrates the use of this feature to
perform the translation of arithmetic expressions into postfix notation directly
by a DCG that does not construct syntax trees. Our first example of this technique
will output the postfix notation.
\[e --+ t, r.\]
\[r --+ [+I, t, write(+)), r.\]
\[r --+ [ 1.\]
\[t --+ [a], (write(a)).\]
This procedure produces the postfix expression using side effects, and this
technique can be a drawback. One solution to this problem is to use difference 
lists to simulate the write procedure. To each DCG clause corresponding to a
nonterminal N we add difference list parameters representing the list of symbols
that are output during the recognition of N. (These difference lists are in addition
to those used in syntactic analysis). We have
\[e(F1, F3) --a t(F1, F2), r(F2, F3).\]
\[r(F1, F4) --+ [+I, t(F1, F2), writefik(+, F2, F3)), r(F3, F4).\]
\[r(F, F) --+ [ 1.\]
\[t(F1, F2) --+ [a], (writefik(a, Fl, F2)).\]
The output is simulated by the procedure writefile(Symbo1, Pos, NewPos) defined
by the unit clause
\[writefile(X, [X 1 B], B).\]

The call ?- e(F, [ 1, [a, +, a, +, a], [ ]]) produces F = [a, a, +, a, +]. This
example shows that difference lists can be used both to select parts of a list and to
construct a list. It is not hard to write a program that automatically performs
the translation from a DCG using write to a DCG using writefile and additional
difference lists. In the remainder of the paper we use the procedure write, and
leave to the interested reader the task of adding difference lists to avoid side
effects. 

The BNF of full-fledged programming languages can be readily transcribed
into DCGs that translate source programs into syntax-trees which can then be
either interpreted or used to generate code. We have tested the DCG needed to
process the entire Pascal language by translating input programs into syntaxtrees.
The following program fragments illustrate this construction for parts of a
mini-language. A while statement is defined by the DCG: 
\begin{verbatim}
statement(while(Test, Do)) --+
[while], test(Test), [do], statement(Do).
\end{verbatim}
A test may be defined by
\begin{verbatim}
test(test(Op, El, E2)) --+ expr(&l),
comP(oP),
expr(E2).
camp(=) --+ [=I.
cow(( )I --+ [( )I.
etc . . .  
\end{verbatim}
The translation of statements into P-code-like instructions is also easily achieved.
For example the statement while T do S can be directly translated into the
sequence
\begin{verbatim}
L: code for test T
jif(i.e, jump if false) to Exit
s
jump to L
Exit:       
\end{verbatim}
If labels are represented by terms of the form label(L) and the instructions by
instr(jif, L) or instr(jump, L), the translation is performed by the DCG:
\begin{verbatim}
statement([label(L), Test, S, instr( jump, L), lubel(Exit)]) --+
[while], test(Test, Exit), [do], statement(S). 
\end{verbatim}
where
\begin{verbatim}
test([Rl, R2, Op, in.str(jif, Exit)], Exit) --+
expr(E1, Rl),
comP(oP),
expr(E2, R2). 
\end{verbatim}
This example illustrates the elegant use of Prolog’s logical variables and unification
in compiling. Each of the variables L and Exit occur twice in the generated
code. When instantiated, each pair will be bound to the same actual value. This
instantiation may occur at a later stage when the final program is assembled and
storage is allocated. Even when using special compiler-writing tools such as
YACC, the implementation of similar constructs requires lengthier programs
since one has to keep track of locations that have to be updated when final
addresses become known. Prolog’s ability to postpone bindings is therefore of
great value in compiling. 

The advantage of using logical variables and delayed binding is also
apparent in managing symbol tables. Consider the procedure Zookup(ldentifier,
Property, Dictionary), in which Dictionary is a list containing the pairs
(identifier-property); lookup’s behavior is similar to that of the procedure
member(E, L) which tests if an element E is present or not in the list L. However,
lookup adds the pair to the Dictionary if it has not been previously added. We
have
\begin{verbatim}
lookup(l, P, [[I, P] 1 T] :- !.
lookup(1, P, [[II, Pl] 1 T] :- lookup(I, P, T).
\end{verbatim}
If lookup is initially called with an uninstantiated variable, the first clause will
create the new pair [I, P] as well as a new uninstantiated variable T. The cut is
needed to prevent backtracking once the desired pair is found or is created. 
Consider now the sequence of calls to lookup:
\begin{verbatim}
lookup(a, Xl, D), lookup(b, X2, D), lookup(a, X3, D). 
\end{verbatim}

The net effect of the above calls is to store the two pairs [a, Xl] and [b, X2] in
D and to bind X3 to Xl. Later on, when Xl and X2 are instantiated, X3 will
automatically be bound to the value of Xl. 

A similar approach is used in [31] to implement binary tables. In that paper,
table lookup is done in the code-generation phase after constructing the syntax
trees (see Section 7). If one wished to perform that operation while parsing, the
DCG rule defining a factor could be
\begin{verbatim}
WU, PI, D) --+ Went(Z (bokup(V, PI, D)J. 
\end{verbatim}
where ident(1) is constructed in a previous scanning pass and the property P is
determined while processing declarations. In this case lookup should be modified
to handle semantic errors such as undeclared identifiers. 

