\secrel{LEXICAL SCANNERS AND PARSER GENERATION }\label{cohen6}

We first note that the syntax of regular expressions is quite similar to that of
arithmetic expressions. The union ( I) replaces the add operator and concatenation
(represented by a blank or period) replaces the multiplication operator. The
star operation may be represented by surrounding a starred sequence by curly
brackets. The translation of a regular expression into its syntax-tree is performed
either using DCGs (Section 4) or triggering the semantic actions described in
Section 3. For examle, the expression ((a 1 b).c).d is translated into the tree:
cone (star (cpnc (union (a, b), c)), d). We now present a recognizer accepting strings
defined by a regular expression given by its syntax-tree. The first argument of
the procedure ret is the syntax-tree, the other two are difference lists (as described
in Section 4).
\begin{verbatim}
rec(L, [L 1 U], U) :- letter(L).
rec(stur(X), U, V) :- rec(X, U, W), rec(stur(X), W, V).
rec(star(X), U, U).
rec(unzbn(X, Y), U, V) :- rec(X, U, V).
rec(union(X, Y), U, V) :- rec(Y, U, V).
rec(conc(X, Y), U, V) :- rec(X, U, W), rec(Y, W, V).  
\end{verbatim}
The above interpreter for regular expressions is admittedly inefficient, since it
relies heavily on backtracking. Nevertheless, it might be suitable for fast prototyping.
An efficient version of the recognizer may be obtained in three steps:

(1) translation of regular expressions into a nondeterministic automaton containing
t moves;

(2) reduction of the automaton in (1) to a deterministic one not containing e
moves (in the cases where the empty symbol is in the language, a complete
elimination of t moves is not possible);

(3) minimization of the automaton obtained in (2). 

The above steps are those performed by LEX, a scanner-generator package
developed at Bell Labs. A Brandeis student, Peter Appel, has prototyped a Prolog
version of LEX in less than one month. His program can handle practically all
features of LEX, but is admittedly slow compared with the original C-version of
that package. When compiled, his program can generate a scanner for a minilanguage
similar to that in the appendix of [l] in about four minutes. However,
it should be noted that Appel’s program is considerably (about five times) shorter
than the C-counterpart, and it took a fairly short time to develop. Since the
Prolog programs are deterministic, further gains in efficiency could be expected
by applying the optimizations suggested by Mellish [21]. In Section 9 we briefly
describe an alternate approach to scanner-generation using proposed extensions
of Prolog. 

In the remainder of this section we sketch two approaches for prototyping
parser generators. The first generates recursive descent parsers, whereas the
second produces SLR(1) parsers of the type used in YACC [ 1].

The recognizer of regular expressions presented earlier in this section can be
easily modified to recognize context-free languages specified by rules whose righthand
sides are themselves regular expressions. For example the rule
\[E --> T(T)\]
can be described by the unit clause
\[ruk(n(e), conc(n(t), star(conc(t(+), n(t))))).\]
The new clause for ret becomes
\[rec(n(A), U, V) :- rule(n(A), R), rec(R, U, V).\]
It is straightforward to prototype a parser generator by implementing the
following steps.

(a) Determine manually the syntax-trees for a grammar B specifying the syntax
of the grammar rules themselves. Each nonterminal N has its corresponding
syntax-tree TN asserted in the database by rule(N, 7~).

(b) Use the modified recognizer ret to parse strings of B, that is, a set of grammar
rules specifying a context-free grammar G.

(c) Attach actions to ret so that it produces the syntax-trees for the grammar G
being read. This step has been described in Section 3.

(d) Once the trees for G are generated, ret itself can be reused to parse the
strings generated by G.

A detailed description of the above steps appears in [14]. A further advantage of
this approach is the possibility it offers to generate efficient recursive descent
parsers [ 7]. One may “compile” assembly language code for a parser by “walking”
on the syntax-tree of a grammar G. 

Another option for parser generation is to use Prolog for producing the tables
for SLR(l) parsers, given a set of grammar rules. An item of a grammar G is a
production of G with a dot at some position of the right-hand side. Each item
can be computed as a triplet (N, D, L) in which N is the rule number, D the dot
position, also an integer, and L is the length of the right-hand side. (One could
also have used only N and D and recomputed L for each rule N whenever needed.)
States are implemented as lists of triplets. The main procedure generates all new
transition states stemming from a given state. Termination occurs when no new
states are generated. Ancillary procedures are needed to check if the element
preceding a dot in a triplet is a nonterminal, or to test if an item has the dot at
the end of a rule. This latter check is readily achieved by testing for (N, L, L).
Another auxiliary procedure determines all triplets that should be added to a
given state once it is found that that state contains items having a dot preceding
a nonterminal. 

The predicate follow (see Section 5) is called to determine the expected window
contents that trigger reductions. These correspond to states containing items
ending with a dot. As in YACC, the parser generator can produce tables with
multiple entries, allowing the user to select the appropriate entry which renders
the parsing deterministic. 

A Prolog version of YACC has been prototyped at Brandeis by Cindy Lurie.
Her program was developed in a couple of months. In addition to generating a
parser, it also produces the code embodying the error-detection and recovery
capabilities suggested by Mickunas and Modry [22]; the correction costs being
interactively supplied by the user (see Section 9). The performance of the Prolog
version of YACC is comparable to that of the LEX counterpart. The previous
remarks about the efficiency remain applicable. A word is in order about the
generated scanners and parsers. They are C-programs which, when optimized,
can approach the efficiency of those generated by LEX and YACC. 

 