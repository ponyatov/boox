\secrel{An Efficient Unification Martelli/Montanary Algorithm}
\label{mmalg}\secdown

\cp{\url{http://www.nsl.com/misc/papers/martelli-montanari.pdf}}

\noindent\copyright \
ALBERTO MARTELLI
Consiglio Nazionale delle Ricerche
\\and\\
UGO MONTANARI
Universita di Pisa
\note{
Authors' present addresses: A. Martelli, Istituto di Scienze della Informazione,
Universit~ di Torino, Corso M. d'Azeglio 42, 1-10125 Torino, Italy; U.
Montanari, Istituto di Scienze della Informazione, Universit\& di Pisa, Corso
Italia 40, 1-56100 Pisa, Italy.

Permission to copy without fee all or part of this material is granted provided
that the copies are not made or distributed for direct commercial advantage, the
ACM copyright notice and the title of the publication and its date appear, and
notice is given that copying is by permission of the Association for Computing
Machinery. To copy otherwise, or to republish, requires a fee and/or specific
permission.

\copyright\ 1982 ACM 0164-0925/82/0400-0258 \$00.75

ACM Transactions on Programming Languages and Systems, Vol. 4, No. 2, April
 1982, Pages 258-282.
}\bigskip

\subsecly{Abstract}

The unification problem in first-order predicate calculus is described in
general terms as the solution of a system of equations, and a nondeterministic
algorithm is given. A new unification algorithm, characterized by having the
acyclicity test efficiently embedded into it, is derived from the
nondeterministic one, and a PASCAL implementation is given. A comparison with
other well-known unification algorithms shows that the algorithm described here
performs well in all cases.

Categories and Subject Descriptors: F.2.2 [Analysis of Algorithms and Problem
Complexity]: Nonnumerical Algorithms and Problems--complexity of proof
procedures; F.4.1 [Mathematical Logic and Formal Languages]: Mathematical
Logic--mechanical theorem proving; 1.2.3 [Artificial Intelligence]: Deduction
and Theorem Proving--resolution

General Terms: Algorithms, Languages, Performance, Theory 

\secrel{INTRODUCTION}

In its essence, the unification problem in first-order logic can be expressed as
follows: Given two terms containing some variables, find, if it exists, the
simplest substitution (i.e., an assignment of some term to every variable) which
makes the two terms equal. The resulting substitution is called the \term{most
general unifier} and is unique up to variable renaming.

Unification was first introduced by Robinson [17, 18] as the central step of the
inference rule called resolution. This single, powerful rule can replace all the
axioms and inference rules of the first-order predicate calculus and thus was
immediately recognized as especially suited to mechanical theorem provers. In
fact, a number of systems based on resolution were built and tried on a variety
of different applications [5]. Even though further research made it apparent
that resolution systems are difficult to direct during proof search and thus are
often prone to combinatorial explosion [6], new impetus to the research in this
area was given by Kowalski's idea of interpreting predicate logic as a
programming language [10]. Here predicate logic clauses are seen as procedure
declarations, and procedure invocation represents a resolution step. From this
viewpoint, theorem provers can be regarded as interpreters for programs written
in predicate logic, and this analogy suggests efficient implementations [3, 25].

Resolution, however, is not the only application of the unification algorithm.
In fact, its pattern matching nature can be exploited in many cases where
symbolic expressions are dealt with, such as, for instance, in interpreters for
equation languages [4, 11], in systems using a database organized in terms of
productions [19], in type checkers for programming languages with a complex type
structure [14], and in the computation of critical pairs for term rewriting
systems [9].

The unification algorithm constitutes the heart of all the applications listed
above, and thus its performance affects in a crucial way the global efficiency
of each. The unification algorithm as originally proposed can be extremely
inefficient; therefore, many attempts have been made to find more efficient
algorithms [2, 7, 13, 15, 16, 22]. Unification algorithms have also been
extended to the case of higher order logic [8] and to deal directly with
associativity and commutativity [20]. The problem was also tackled from a
computational complexity point of view, and linear algorithms were proposed
independently by Martelli and Montanari [13] and Paterson and Wegman [15].

In the next section we give some basic definitions by representing the
unification problem as the solution of a system of equations. A nondeterministic
algorithm, which comprehends as special cases most known algorithms, is then
defined and proved correct. In Section 3 we present a new version of this
algorithm obtained by grouping together all equations with some member in
common, and we derive from it a first version of our unification algorithm.

In Sections 4 and 5 we present the main ideas which make the algorithm
efficient, and the last details are described in Section 6 by means of a PASCAL
implementation.

Finally, in Section 7, the performance of this algorithm is compared with that
of two well-known algorithms, Huet's [7] and Paterson and Wegman's [15]. This
analysis shows that our algorithm has uniformly good performance for all classes
of data considered.

\secrel{UNIFICATION AS THE SOLUTION OF A SET OF EQUATIONS: A NONDETERMINISTIC
ALGORITHM}

In this section we introduce the basic definitions and give a few theorems which
are useful in proving the correctness of the algorithms. Our ay of stating the
unification problem is slightly more general than the classical one due to
Robinson [18] and directly suggests a number of possible solution methods.

Let
\[A= \bigcup_{i=0,1,..} A_i \quad (A_i \bigcap A_j = \varnothing, i \neq j)\] be
a ranked alphabet, where $A_i$ contains the $i$-adic function symbols
(the elements of $A_0$ are constant symbols). Furthermore, let $V$ be the
alphabet of the variables.
The \term{terms} are defined recursively as follows:

(1) constant symbols and variables are terms;

(2) if $t_1,..,t_n \ (n \geq 1)$ are terms and $f \in A_n$,
then $f(t_1,..,t_n)$ is a term.

A \term{substitution} $\vartheta$ is a mapping from variables to terms,
with $\vartheta(x)=x$ almost everywhere. A substitution can be represented
by a finite set of ordered pairs
$\vartheta={(t_1,x_1),(t_2,x_2),..,(t_m,x_m)}$
where $t_i$ are terms and $x_i$ are distinct variables,
$i = 1,..,m$. To apply a substitution $\vartheta$ to a term $t$, we
simultaneously substitute all occurrences in $t$ of every variable $x_i$ in a
pair $(t_i, x_i)$ of $\vartheta$ with the corresponding term $t_i$. We call the
resulting term $t_\vartheta$.

For instance, given a term $t = f(x_1, g(x_2, a)$ and a substitution 
$\vartheta = {(h(x_2),x_1),(b,x_2)}$, 
we have $t_\vartheta = f(f(x_2),g(b),a)$ and $t_{\vartheta\vartheta} =
f(h(b),g(b),a))$.

The standard unification problem can be written as an equation \[t'=t''\]

A solution of the equation, called a \term{unifier}, is any substitution
$\vartheta$, if it exists, which makes the two terms identical. For instance,
two unifiers of the equation $f(x_1,h(x_1),x_2)=f(g(x_3),x_4,x_3))$ are
$\vartheta_1={(g(x_3),x_1),(x_3,x_2),(h(g(x_3)),x_4)}$ and
$\vartheta_2={(g(a),x_1),(a,x_2),(a,x_3),(h(g(a)),x_4)}$.

In what follows it is convenient also to consider sets of equations
\[t'_j=t''_j, \quad j=1,..,k\]

Again, a \term{unifier} is any substitution which makes all pairs of terms
$t'_j,t''_j$ identical simultaneously.

Now we are interested in finding transformations which produce \emph{equivalent}
sets of equations, namely, transformations which preserve the sets of all
unifiers.
Let us introduce the following two transformations:

\paragraph{(1) Term Reduction.} Let

\begin{equation}\label{mm1}
f(t'_1,t'_2,..,t'_n)=f(t''_1,t''_2,..,t''_n), \quad f \in A_n
\end{equation} 
be an equation where both terms are not variables and where the two root
function symbols are equal. The new set of equations is obtained by replacing
this equation with the following ones: 
\begin{align}\label{mm2}
t'_1 &= t''_1\\
t'_2 &= t''_2\\
&.\\
&.\\
&.\\
t'_n &= t''_n
\end{align}
If $n = 0$, then $f$ is a constant symbol, and the equation is simply erased.

\paragraph{(2) Variable Elimination.} Let $x = t$ be an equation where $x$ is a
variable and $t$ is any term (variable or not). The new set of equations is
obtained by applying the substitution $\vartheta={(t,x)}$ to both terms of all
other equations in the set (without erasing $x = t$).

We can prove the following theorems: 

\paragraph{THEOREM 2.1.} \textit{Let $S$ be a set of equations and let
$f'(t'_1,..t'_n)=f''(t''_1,..,t''_n)$ be an equation of $S$. If $f' \neq f''$,
then $S$ has no unifier. Otherwise, the new set of equations $S'$, obtained by
applying term reduction to the given equation, is equivalent to $S$.}

\paragraph{PROOF.} If $f' \neq f''$, then no substitution can make the
two terms identical.
If $f' = f"$, any substitution which satisfies \ref{mm2} also satisfies
\ref{mm1}, and conversely for the recursive definition of term. $\square$

\paragraph{THEOREM 2.2.} \textit{Let $S$ be a set of equations, and let us apply
variable elimination to some equation $x = t$, getting a new set of equations
$S'$. If variable $x$ occurs in $t$ (but $t$ is not $x$), then $S$ has no
unifier; otherwise, $S$ and $S'$ are equivalent.}

\paragraph{PROOF.} Equation $x = t$ belongs both to $S$ and to $S'$, and thus
any unifier $\vartheta$ (if it exists) of $S$ or of $S'$ must unify $x$ and $t$;
that is, $x_\vartheta$ and $t_\vartheta$ are identical. Now let $t_1 = t_2$ be
any other equation of $S$, and let $t'_1 = t'_2$ be the corresponding equation
in $S'$. Since $t'_1$ and $t'_2$ have been obtained by substituting $t$ for
every occurrence of $x$ in $t_1$ and $t_2$, respectively, we have
$t_{1_\vartheta}=t'_{1_\vartheta}$ and $t_{2_\vartheta}=t'_{2_\vartheta}$. Thus,
any unifier of $S$ is also a unifier of $S'$ and vice versa. Furthermore, if
variable $x$ occurs in $t$ (but $t$ is not $x$), then no substitution
$\vartheta$ can make $x$ and $t$ identical, since $x_\vartheta$ becomes a
subterm of $t_\vartheta$, and thus $S$ has no unifier. $\square$
  
\secup